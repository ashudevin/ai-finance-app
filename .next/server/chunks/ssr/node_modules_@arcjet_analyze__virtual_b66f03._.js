module.exports = {

"[project]/node_modules/@arcjet/analyze/_virtual/arcjet_analyze_js_req.component.core2.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
// @generated by wasm2module - DO NOT EDIT
/* eslint-disable */ // @ts-nocheck
/**
 * This file contains an Arcjet Wasm binary inlined as a base64
 * [Data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)
 * with the application/wasm MIME type.
 *
 * This was chosen to save on storage space over inlining the file directly as
 * a Uint8Array, which would take up ~3x the space of the Wasm file. See
 * https://blobfolio.com/2019/better-binary-batter-mixing-base64-and-uint8array/
 * for more details.
 *
 * It is then decoded into an ArrayBuffer to be used directly via WebAssembly's
 * `compile()` function in our entry point file.
 *
 * This is all done to avoid trying to read or bundle the Wasm asset in various
 * ways based on the platform or bundler a user is targeting. One example being
 * that Next.js requires special `asyncWebAssembly` webpack config to load our
 * Wasm file if we don't do this.
 *
 * In the future, we hope to do away with this workaround when all bundlers
 * properly support consistent asset bundling techniques.
 */ __turbopack_esm__({
    "wasm": (()=>wasm)
});
const wasmBase64 = "data:application/wasm;base64,AGFzbQEAAAABFQNgBH9/f38Bf2ACf38Bf2ADf39/AAMHBgABAQEBAgQFAXABBgYHJAcBMAAAATEAAQEyAAIBMwADATQABAE1AAUIJGltcG9ydHMBAApPBg8AIAAgASACIANBABEAAAsLACAAIAFBAREBAAsLACAAIAFBAhEBAAsLACAAIAFBAxEBAAsLACAAIAFBBBEBAAsNACAAIAEgAkEFEQIACwAvCXByb2R1Y2VycwEMcHJvY2Vzc2VkLWJ5AQ13aXQtY29tcG9uZW50BzAuMjE5LjEAjgMEbmFtZQATEndpdC1jb21wb25lbnQ6c2hpbQHxAgYAKGluZGlyZWN0LWFyY2pldDpqcy1yZXEvdmVyaWZ5LWJvdC12ZXJpZnkBPmluZGlyZWN0LWFyY2pldDpqcy1yZXEvZW1haWwtdmFsaWRhdG9yLW92ZXJyaWRlcy1pcy1mcmVlLWVtYWlsAkRpbmRpcmVjdC1hcmNqZXQ6anMtcmVxL2VtYWlsLXZhbGlkYXRvci1vdmVycmlkZXMtaXMtZGlzcG9zYWJsZS1lbWFpbAM/aW5kaXJlY3QtYXJjamV0OmpzLXJlcS9lbWFpbC12YWxpZGF0b3Itb3ZlcnJpZGVzLWhhcy1teC1yZWNvcmRzBD1pbmRpcmVjdC1hcmNqZXQ6anMtcmVxL2VtYWlsLXZhbGlkYXRvci1vdmVycmlkZXMtaGFzLWdyYXZhdGFyBT5pbmRpcmVjdC1hcmNqZXQ6anMtcmVxL3NlbnNpdGl2ZS1pbmZvcm1hdGlvbi1pZGVudGlmaWVyLWRldGVjdA==";
/**
 * Returns a WebAssembly.Module for an Arcjet Wasm binary, decoded from a base64
 * Data URL.
 */ // TODO: Switch back to top-level await when our platforms all support it
async function wasm() {
    // This uses fetch to decode the wasm data url, but disabling cache so files
    // larger than 2mb don't fail to parse in the Next.js App Router
    const wasmDecode = await fetch(wasmBase64, {
        cache: "no-store"
    });
    const buf = await wasmDecode.arrayBuffer();
    // And then we return it as a WebAssembly.Module
    return WebAssembly.compile(buf);
}
;
}}),
"[project]/node_modules/@arcjet/analyze/_virtual/arcjet_analyze_js_req.component.core3.js [app-rsc] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { r: __turbopack_require__, f: __turbopack_module_context__, i: __turbopack_import__, s: __turbopack_esm__, v: __turbopack_export_value__, n: __turbopack_export_namespace__, c: __turbopack_cache__, M: __turbopack_modules__, l: __turbopack_load__, j: __turbopack_dynamic__, P: __turbopack_resolve_absolute_path__, U: __turbopack_relative_url__, R: __turbopack_resolve_module_id_path__, b: __turbopack_worker_blob_url__, g: global, __dirname, x: __turbopack_external_require__, y: __turbopack_external_import__, z: require } = __turbopack_context__;
{
// @generated by wasm2module - DO NOT EDIT
/* eslint-disable */ // @ts-nocheck
/**
 * This file contains an Arcjet Wasm binary inlined as a base64
 * [Data URL](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URLs)
 * with the application/wasm MIME type.
 *
 * This was chosen to save on storage space over inlining the file directly as
 * a Uint8Array, which would take up ~3x the space of the Wasm file. See
 * https://blobfolio.com/2019/better-binary-batter-mixing-base64-and-uint8array/
 * for more details.
 *
 * It is then decoded into an ArrayBuffer to be used directly via WebAssembly's
 * `compile()` function in our entry point file.
 *
 * This is all done to avoid trying to read or bundle the Wasm asset in various
 * ways based on the platform or bundler a user is targeting. One example being
 * that Next.js requires special `asyncWebAssembly` webpack config to load our
 * Wasm file if we don't do this.
 *
 * In the future, we hope to do away with this workaround when all bundlers
 * properly support consistent asset bundling techniques.
 */ __turbopack_esm__({
    "wasm": (()=>wasm)
});
const wasmBase64 = "data:application/wasm;base64,AGFzbQEAAAABFQNgBH9/f38Bf2ACf38Bf2ADf39/AAIuBwABMAAAAAExAAEAATIAAQABMwABAAE0AAEAATUAAgAIJGltcG9ydHMBcAEGBgkMAQBBAAsGAAECAwQFAC8JcHJvZHVjZXJzAQxwcm9jZXNzZWQtYnkBDXdpdC1jb21wb25lbnQHMC4yMTkuMQAcBG5hbWUAFRR3aXQtY29tcG9uZW50OmZpeHVwcw==";
/**
 * Returns a WebAssembly.Module for an Arcjet Wasm binary, decoded from a base64
 * Data URL.
 */ // TODO: Switch back to top-level await when our platforms all support it
async function wasm() {
    // This uses fetch to decode the wasm data url, but disabling cache so files
    // larger than 2mb don't fail to parse in the Next.js App Router
    const wasmDecode = await fetch(wasmBase64, {
        cache: "no-store"
    });
    const buf = await wasmDecode.arrayBuffer();
    // And then we return it as a WebAssembly.Module
    return WebAssembly.compile(buf);
}
;
}}),

};

//# sourceMappingURL=node_modules_%40arcjet_analyze__virtual_b66f03._.js.map