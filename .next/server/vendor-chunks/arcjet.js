"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/arcjet";
exports.ids = ["vendor-chunks/arcjet"];
exports.modules = {

/***/ "(rsc)/./node_modules/arcjet/index.js":
/*!**************************************!*\
  !*** ./node_modules/arcjet/index.js ***!
  \**************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArcjetAllowDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetAllowDecision),\n/* harmony export */   ArcjetBotReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason),\n/* harmony export */   ArcjetChallengeDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetChallengeDecision),\n/* harmony export */   ArcjetConclusion: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetConclusion),\n/* harmony export */   ArcjetDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDecision),\n/* harmony export */   ArcjetDenyDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision),\n/* harmony export */   ArcjetEdgeRuleReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEdgeRuleReason),\n/* harmony export */   ArcjetEmailReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason),\n/* harmony export */   ArcjetEmailType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailType),\n/* harmony export */   ArcjetErrorDecision: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision),\n/* harmony export */   ArcjetErrorReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason),\n/* harmony export */   ArcjetIpDetails: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetIpDetails),\n/* harmony export */   ArcjetMode: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetMode),\n/* harmony export */   ArcjetRateLimitAlgorithm: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitAlgorithm),\n/* harmony export */   ArcjetRateLimitReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRateLimitReason),\n/* harmony export */   ArcjetReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason),\n/* harmony export */   ArcjetRuleResult: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult),\n/* harmony export */   ArcjetRuleState: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleState),\n/* harmony export */   ArcjetRuleType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleType),\n/* harmony export */   ArcjetSensitiveInfoReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason),\n/* harmony export */   ArcjetSensitiveInfoType: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoType),\n/* harmony export */   ArcjetShieldReason: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetShieldReason),\n/* harmony export */   ArcjetStack: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetStack),\n/* harmony export */   botCategories: () => (/* reexport safe */ _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.botCategories),\n/* harmony export */   \"default\": () => (/* binding */ arcjet),\n/* harmony export */   detectBot: () => (/* binding */ detectBot),\n/* harmony export */   fixedWindow: () => (/* binding */ fixedWindow),\n/* harmony export */   protectSignup: () => (/* binding */ protectSignup),\n/* harmony export */   sensitiveInfo: () => (/* binding */ sensitiveInfo),\n/* harmony export */   shield: () => (/* binding */ shield),\n/* harmony export */   slidingWindow: () => (/* binding */ slidingWindow),\n/* harmony export */   tokenBucket: () => (/* binding */ tokenBucket),\n/* harmony export */   validateEmail: () => (/* binding */ validateEmail)\n/* harmony export */ });\n/* harmony import */ var _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @arcjet/protocol */ \"(rsc)/./node_modules/@arcjet/protocol/index.js\");\n/* harmony import */ var _arcjet_protocol_convert_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @arcjet/protocol/convert.js */ \"(rsc)/./node_modules/@arcjet/protocol/convert.js\");\n/* harmony import */ var _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @arcjet/analyze */ \"(rsc)/./node_modules/@arcjet/analyze/index.js\");\n/* harmony import */ var _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @arcjet/duration */ \"(rsc)/./node_modules/@arcjet/duration/index.js\");\n/* harmony import */ var _arcjet_headers__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @arcjet/headers */ \"(rsc)/./node_modules/@arcjet/headers/index.js\");\n/* harmony import */ var _arcjet_runtime__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @arcjet/runtime */ \"(rsc)/./node_modules/@arcjet/runtime/index.js\");\n/* harmony import */ var _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @arcjet/stable-hash */ \"(rsc)/./node_modules/@arcjet/stable-hash/index.js\");\n\n\n\n\n\n\n\n\n\nfunction assert(condition, msg) {\n    if (!condition) {\n        throw new Error(msg);\n    }\n}\nfunction nowInSeconds() {\n    return Math.floor(Date.now() / 1000);\n}\nclass Cache {\n    expires;\n    data;\n    constructor() {\n        this.expires = new Map();\n        this.data = new Map();\n    }\n    get(key) {\n        const ttl = this.ttl(key);\n        if (ttl > 0) {\n            return this.data.get(key);\n        }\n        else {\n            // Cleanup if expired\n            this.expires.delete(key);\n            this.data.delete(key);\n        }\n    }\n    set(key, value, expiresAt) {\n        this.expires.set(key, expiresAt);\n        this.data.set(key, value);\n    }\n    ttl(key) {\n        const now = nowInSeconds();\n        const expiresAt = this.expires.get(key) ?? now;\n        return expiresAt - now;\n    }\n}\nfunction errorMessage(err) {\n    if (err) {\n        if (typeof err === \"string\") {\n            return err;\n        }\n        if (typeof err === \"object\" &&\n            \"message\" in err &&\n            typeof err.message === \"string\") {\n            return err.message;\n        }\n    }\n    return \"Unknown problem\";\n}\nconst knownFields = [\n    \"ip\",\n    \"method\",\n    \"protocol\",\n    \"host\",\n    \"path\",\n    \"headers\",\n    \"body\",\n    \"email\",\n    \"cookies\",\n    \"query\",\n];\nfunction isUnknownRequestProperty(key) {\n    return !knownFields.includes(key);\n}\nfunction isEmailType(type) {\n    return (type === \"FREE\" ||\n        type === \"DISPOSABLE\" ||\n        type === \"NO_MX_RECORDS\" ||\n        type === \"NO_GRAVATAR\" ||\n        type === \"INVALID\");\n}\nclass Performance {\n    log;\n    constructor(logger) {\n        this.log = logger;\n    }\n    // TODO(#2020): We should no-op this if loglevel is not `debug` to do less work\n    measure(label) {\n        const start = performance.now();\n        return () => {\n            const end = performance.now();\n            const diff = end - start;\n            this.log.debug(\"LATENCY %s: %sms\", label, diff.toFixed(3));\n        };\n    }\n}\nfunction toString(value) {\n    if (typeof value === \"string\") {\n        return value;\n    }\n    if (typeof value === \"number\") {\n        return `${value}`;\n    }\n    if (typeof value === \"boolean\") {\n        return value ? \"true\" : \"false\";\n    }\n    return \"<unsupported value>\";\n}\n// This is the Symbol that Vercel defines in their infrastructure to access the\n// Context (where available). The Context can contain the `waitUntil` function.\n// https://github.com/vercel/vercel/blob/930d7fb892dc26f240f2b950d963931c45e1e661/packages/functions/src/get-context.ts#L6\nconst SYMBOL_FOR_REQ_CONTEXT = Symbol.for(\"@vercel/request-context\");\nfunction lookupWaitUntil() {\n    const fromSymbol = globalThis;\n    if (typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT] === \"object\" &&\n        fromSymbol[SYMBOL_FOR_REQ_CONTEXT] !== null &&\n        \"get\" in fromSymbol[SYMBOL_FOR_REQ_CONTEXT] &&\n        typeof fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get === \"function\") {\n        const vercelCtx = fromSymbol[SYMBOL_FOR_REQ_CONTEXT].get();\n        if (typeof vercelCtx === \"object\" &&\n            vercelCtx !== null &&\n            \"waitUntil\" in vercelCtx &&\n            typeof vercelCtx.waitUntil === \"function\") {\n            return vercelCtx.waitUntil;\n        }\n    }\n}\nfunction toAnalyzeRequest(request) {\n    const headers = {};\n    if (typeof request.headers !== \"undefined\") {\n        for (const [key, value] of request.headers.entries()) {\n            headers[key] = value;\n        }\n    }\n    return {\n        ...request,\n        headers,\n    };\n}\nfunction extraProps(details) {\n    const extra = new Map();\n    for (const [key, value] of Object.entries(details)) {\n        if (isUnknownRequestProperty(key)) {\n            extra.set(key, toString(value));\n        }\n    }\n    return Object.fromEntries(extra.entries());\n}\nfunction createTypeValidator(...types) {\n    return (key, value) => {\n        const typeOfValue = typeof value;\n        if (!types.includes(typeOfValue)) {\n            if (types.length === 1) {\n                throw new Error(`invalid type for \\`${key}\\` - expected ${types[0]}`);\n            }\n            else {\n                throw new Error(`invalid type for \\`${key}\\` - expected one of ${types.join(\", \")}`);\n            }\n        }\n        else {\n            return false;\n        }\n    };\n}\nfunction createValueValidator(\n// This uses types to ensure we have at least 2 values\n...values) {\n    return (key, value) => {\n        // We cast the values to unknown because the optionValue isn't known but\n        // we only want to use `values` on string enumerations\n        if (!values.includes(value)) {\n            throw new Error(`invalid value for \\`${key}\\` - expected one of ${values.map((value) => `'${value}'`).join(\", \")}`);\n        }\n    };\n}\nfunction createArrayValidator(validate) {\n    return (key, value) => {\n        if (Array.isArray(value)) {\n            for (const [idx, item] of value.entries()) {\n                validate(`${key}[${idx}]`, item);\n            }\n        }\n        else {\n            throw new Error(`invalid type for \\`${key}\\` - expected an array`);\n        }\n    };\n}\nfunction createValidator({ rule, validations, }) {\n    return (options) => {\n        for (const { key, validate, required } of validations) {\n            if (required && !Object.hasOwn(options, key)) {\n                throw new Error(`\\`${rule}\\` options error: \\`${key}\\` is required`);\n            }\n            const value = options[key];\n            // The `required` flag is checked above, so these should only be validated\n            // if the value is not undefined.\n            if (typeof value !== \"undefined\") {\n                try {\n                    validate(key, value);\n                }\n                catch (err) {\n                    throw new Error(`\\`${rule}\\` options error: ${errorMessage(err)}`);\n                }\n            }\n        }\n    };\n}\nconst validateString = createTypeValidator(\"string\");\nconst validateNumber = createTypeValidator(\"number\");\nconst validateBoolean = createTypeValidator(\"boolean\");\nconst validateFunction = createTypeValidator(\"function\");\nconst validateStringOrNumber = createTypeValidator(\"string\", \"number\");\nconst validateStringArray = createArrayValidator(validateString);\nconst validateMode = createValueValidator(\"LIVE\", \"DRY_RUN\");\nconst validateEmailTypes = createArrayValidator(createValueValidator(\"DISPOSABLE\", \"FREE\", \"NO_MX_RECORDS\", \"NO_GRAVATAR\", \"INVALID\"));\nconst validateTokenBucketOptions = createValidator({\n    rule: \"tokenBucket\",\n    validations: [\n        {\n            key: \"mode\",\n            required: false,\n            validate: validateMode,\n        },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"refillRate\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n        { key: \"capacity\", required: true, validate: validateNumber },\n    ],\n});\nconst validateFixedWindowOptions = createValidator({\n    rule: \"fixedWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"window\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSlidingWindowOptions = createValidator({\n    rule: \"slidingWindow\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        {\n            key: \"characteristics\",\n            validate: validateStringArray,\n            required: false,\n        },\n        { key: \"max\", required: true, validate: validateNumber },\n        { key: \"interval\", required: true, validate: validateStringOrNumber },\n    ],\n});\nconst validateSensitiveInfoOptions = createValidator({\n    rule: \"sensitiveInfo\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n        { key: \"contextWindowSize\", required: false, validate: validateNumber },\n        { key: \"detect\", required: false, validate: validateFunction },\n    ],\n});\nconst validateEmailOptions = createValidator({\n    rule: \"validateEmail\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"block\", required: false, validate: validateEmailTypes },\n        { key: \"allow\", required: false, validate: validateEmailTypes },\n        { key: \"deny\", required: false, validate: validateEmailTypes },\n        {\n            key: \"requireTopLevelDomain\",\n            required: false,\n            validate: validateBoolean,\n        },\n        { key: \"allowDomainLiteral\", required: false, validate: validateBoolean },\n    ],\n});\nconst validateBotOptions = createValidator({\n    rule: \"detectBot\",\n    validations: [\n        { key: \"mode\", required: false, validate: validateMode },\n        { key: \"allow\", required: false, validate: validateStringArray },\n        { key: \"deny\", required: false, validate: validateStringArray },\n    ],\n});\nconst validateShieldOptions = createValidator({\n    rule: \"shield\",\n    validations: [{ key: \"mode\", required: false, validate: validateMode }],\n});\nconst Priority = {\n    SensitiveInfo: 1,\n    Shield: 2,\n    RateLimit: 3,\n    BotDetection: 4,\n    EmailValidation: 5,\n};\nfunction isLocalRule(rule) {\n    return (\"validate\" in rule &&\n        typeof rule.validate === \"function\" &&\n        \"protect\" in rule &&\n        typeof rule.protect === \"function\");\n}\n/**\n * Arcjet token bucket rate limiting rule. Applying this rule sets a token\n * bucket rate limit.\n *\n * This algorithm is based on a bucket filled with a specific number of tokens.\n * Each request withdraws some amount of tokens from the bucket and the bucket\n * is refilled at a fixed rate. Once the bucket is empty, the client is blocked\n * until the bucket refills.\n *\n * This algorithm is useful when you want to allow clients to make a burst of\n * requests and then still be able to make requests at a slower rate.\n *\n * @param {TokenBucketRateLimitOptions} options - The options for the token\n * bucket rate limiting rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate limit is\n * exceeded, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {number} options.refillRate - The number of tokens to add to the\n * bucket at each interval. For example, if you set the interval to 60 and the\n * refill rate to 10, the bucket will refill 10 tokens every 60 seconds.\n * @param {string | number} options.interval - The time interval for the refill\n * rate. This can be a string like `\"60s\"` for 60 seconds, `\"1h45m\"` for 1 hour\n * and 45 minutes, or a number like `60` for 60 seconds. Valid string time units\n * are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.capacity - The maximum number of tokens the bucket\n * can hold. The bucket starts at full capacity and will refill until it hits\n * the capacity.\n * @returns {Primitive} The token bucket rule to provide to the SDK in the\n * `rules` option.\n *\n * @example\n * ```ts\n * tokenBucket({ mode: \"LIVE\", refillRate: 10, interval: \"60s\", capacity: 100 });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     tokenBucket({\n *       mode: \"LIVE\",\n *       refillRate: 10,\n *       interval: \"60s\",\n *       capacity: 100,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#token-bucket\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction tokenBucket(options) {\n    validateTokenBucketOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const refillRate = options.refillRate;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__.parse(options.interval);\n    const capacity = options.capacity;\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"TOKEN_BUCKET\",\n        refillRate,\n        interval,\n        capacity,\n    };\n    return [rule];\n}\n/**\n * Arcjet fixed window rate limiting rule. Applying this rule sets a fixed\n * window rate limit which tracks the number of requests made by a client over a\n * fixed time window.\n *\n * This is the simplest algorithm. It tracks the number of requests made by a\n * client over a fixed time window e.g. 60 seconds. If the client exceeds the\n * limit, they are blocked until the window expires.\n *\n * This algorithm is useful when you want to apply a simple fixed limit in a\n * fixed time window. For example, a simple limit on the total number of\n * requests a client can make. However, it can be susceptible to the stampede\n * problem where a client makes a burst of requests at the start of a window and\n * then is blocked for the rest of the window. The sliding window algorithm can\n * be used to avoid this.\n *\n * @param {FixedWindowRateLimitOptions} options - The options for the fixed\n * window rate limiting rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate limit is\n * exceeded, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {string | number} options.window - The fixed time window. This can be\n * a string like `\"60s\"` for 60 seconds, `\"1h45m\"` for 1 hour and 45 minutes, or\n * a number like `60` for 60 seconds. Valid string time units are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.max - The maximum number of requests allowed in the\n * fixed time window.\n * @returns {Primitive} The fixed window rule to provide to the SDK in the\n * `rules` option.\n *\n * @example\n * ```ts\n * fixedWindow({ mode: \"LIVE\", window: \"60s\", max: 100 });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *    key: process.env.ARCJET_KEY,\n *   rules: [\n *     fixedWindow({\n *       mode: \"LIVE\",\n *       window: \"60s\",\n *       max: 100,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#fixed-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction fixedWindow(options) {\n    validateFixedWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const window = _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__.parse(options.window);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"FIXED_WINDOW\",\n        max,\n        window,\n    };\n    return [rule];\n}\n/**\n * Arcjet sliding window rate limiting rule. Applying this rule sets a sliding\n * window rate limit which tracks the number of requests made by a client over a\n * sliding window so that the window moves with time.\n *\n * This algorithm is useful to avoid the stampede problem of the fixed window.\n * It provides smoother rate limiting over time and can prevent a client from\n * making a burst of requests at the start of a window and then being blocked\n * for the rest of the window.\n *\n * @param {SlidingWindowRateLimitOptions} options - The options for the sliding\n * window rate limiting rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate limit is\n * exceeded, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {string | number} options.interval - The time interval for the rate\n * limit. This can be a string like `\"60s\"` for 60 seconds, `\"1h45m\"` for 1 hour\n * and 45 minutes, or a number like `60` for 60 seconds. Valid string time units\n * are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.max - The maximum number of requests allowed in the\n * sliding time window.\n * @returns {Primitive} The sliding window rule to provide to the SDK in the\n * `rules` option.\n *\n * @example\n * ```ts\n * slidingWindow({ mode: \"LIVE\", interval: \"60s\", max: 100 });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     slidingWindow({\n *       mode: \"LIVE\",\n *       interval: \"60s\",\n *       max: 100,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/rate-limiting/concepts\n * @link https://docs.arcjet.com/rate-limiting/algorithms#sliding-window\n * @link https://docs.arcjet.com/rate-limiting/reference\n */\nfunction slidingWindow(options) {\n    validateSlidingWindowOptions(options);\n    const type = \"RATE_LIMIT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const characteristics = Array.isArray(options.characteristics)\n        ? options.characteristics\n        : undefined;\n    const max = options.max;\n    const interval = _arcjet_duration__WEBPACK_IMPORTED_MODULE_3__.parse(options.interval);\n    const rule = {\n        type,\n        version,\n        priority: Priority.RateLimit,\n        mode,\n        characteristics,\n        algorithm: \"SLIDING_WINDOW\",\n        max,\n        interval,\n    };\n    return [rule];\n}\nfunction protocolSensitiveInfoEntitiesToAnalyze(entity) {\n    if (typeof entity !== \"string\") {\n        throw new Error(\"invalid entity type\");\n    }\n    if (entity === \"EMAIL\") {\n        return { tag: \"email\" };\n    }\n    if (entity === \"PHONE_NUMBER\") {\n        return { tag: \"phone-number\" };\n    }\n    if (entity === \"IP_ADDRESS\") {\n        return { tag: \"ip-address\" };\n    }\n    if (entity === \"CREDIT_CARD_NUMBER\") {\n        return { tag: \"credit-card-number\" };\n    }\n    return {\n        tag: \"custom\",\n        val: entity,\n    };\n}\nfunction analyzeSensitiveInfoEntitiesToString(entity) {\n    if (entity.tag === \"email\") {\n        return \"EMAIL\";\n    }\n    if (entity.tag === \"ip-address\") {\n        return \"IP_ADDRESS\";\n    }\n    if (entity.tag === \"credit-card-number\") {\n        return \"CREDIT_CARD_NUMBER\";\n    }\n    if (entity.tag === \"phone-number\") {\n        return \"PHONE_NUMBER\";\n    }\n    return entity.val;\n}\nfunction convertAnalyzeDetectedSensitiveInfoEntity(detectedEntities) {\n    return detectedEntities.map((detectedEntity) => {\n        return {\n            ...detectedEntity,\n            identifiedType: analyzeSensitiveInfoEntitiesToString(detectedEntity.identifiedType),\n        };\n    });\n}\n/**\n * Arcjet sensitive information detection rule. Applying this rule protects\n * against clients sending you sensitive information such as personally\n * identifiable information (PII) that you do not wish to handle. The rule runs\n * entirely locally so no data ever leaves your environment.\n *\n * This rule includes built-in detections for email addresses, credit/debit card\n * numbers, IP addresses, and phone numbers. You can also provide a custom\n * detection function to identify additional sensitive information.\n *\n * @param {SensitiveInfoOptions} options - The options for the sensitive\n * information detection rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when any of the\n * configured sensitive information types are detected, and `\"DRY_RUN\"` will\n * allow all requests while still providing access to the rule results. Defaults\n * to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetSensitiveInfoType>} options.deny - The list of sensitive\n * information types to deny. If provided, the sensitive information types in\n * this list will be denied. You may only provide either `allow` or `deny`, not\n * both. Specify one or more of the following:\n *\n * - `\"EMAIL\"`\n * - `\"PHONE_NUMBER\"`\n * - `\"IP_ADDRESS\"`\n * - `\"CREDIT_CARD_NUMBER\"`\n * @param {Array<ArcjetSensitiveInfoType>} options.allow - The list of sensitive\n * information types to allow. If provided, types in this list will be allowed\n * and all others will be denied. You may only provide either `allow` or `deny`,\n * not both. The same options apply as for `deny`.\n * @param {DetectSensitiveInfoEntities} options.detect - A custom detection\n * function. The function will take a list of tokens and must return a list of\n * either `undefined`, if the corresponding token in the input list is not\n * sensitive, or the name of the entity if it does match. The number of tokens\n * that are provided to the function is controlled by the `contextWindowSize`\n * option, which defaults to `1`. If you need additional context to perform\n * detections then you can increase this value.\n * @param {number} options.contextWindowSize - The number of tokens to provide\n * to the custom detection function. This defaults to 1 if not specified.\n * @returns {Primitive} The sensitive information rule to provide to the SDK in\n * the `rules` option.\n *\n * @example\n * ```ts\n * sensitiveInfo({ mode: \"LIVE\", deny: [\"EMAIL\"] });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     sensitiveInfo({\n *       mode: \"LIVE\",\n *       deny: [\"EMAIL\"],\n *     })\n *   ],\n * });\n * ```\n * @example\n * Custom detection function:\n * ```ts\n * function detectDash(tokens: string[]): Array<\"CONTAINS_DASH\" | undefined> {\n *   return tokens.map((token) => {\n *     if (token.includes(\"-\")) {\n *       return \"CONTAINS_DASH\";\n *     }\n *   });\n * }\n *\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     sensitiveInfo({\n *       mode: \"LIVE\",\n *       deny: [\"EMAIL\", \"CONTAINS_DASH\"],\n *       detect: detectDash,\n *       contextWindowSize: 2,\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/sensitive-info/concepts\n * @link https://docs.arcjet.com/sensitive-info/reference\n */\nfunction sensitiveInfo(options) {\n    validateSensitiveInfoOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`sensitiveInfo` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"SENSITIVE_INFO\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow || [];\n    const deny = options.deny || [];\n    const id = _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.stringSliceOrdered(\"deny\", deny));\n    const rule = {\n        version,\n        priority: Priority.SensitiveInfo,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) { },\n        async protect(context, details) {\n            const ruleId = await id;\n            const body = await context.getBody();\n            if (typeof body === \"undefined\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 0,\n                    state: \"NOT_RUN\",\n                    conclusion: \"ERROR\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Couldn't read the body of the request to perform sensitive info identification.\"),\n                });\n            }\n            let convertedDetect = undefined;\n            if (typeof options.detect !== \"undefined\") {\n                const detect = options.detect;\n                convertedDetect = (tokens) => {\n                    return detect(tokens)\n                        .filter((e) => typeof e !== \"undefined\")\n                        .map(protocolSensitiveInfoEntitiesToAnalyze);\n                };\n            }\n            let entitiesTag = \"allow\";\n            let entitiesVal = [];\n            if (Array.isArray(options.allow)) {\n                entitiesTag = \"allow\";\n                entitiesVal = options.allow\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            if (Array.isArray(options.deny)) {\n                entitiesTag = \"deny\";\n                entitiesVal = options.deny\n                    .filter((e) => typeof e !== \"undefined\")\n                    .map(protocolSensitiveInfoEntitiesToAnalyze);\n            }\n            const entities = {\n                tag: entitiesTag,\n                val: entitiesVal,\n            };\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.detectSensitiveInfo(context, body, entities, options.contextWindowSize || 1, convertedDetect);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            const reason = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetSensitiveInfoReason({\n                denied: convertAnalyzeDetectedSensitiveInfoEntity(result.denied),\n                allowed: convertAnalyzeDetectedSensitiveInfoEntity(result.allowed),\n            });\n            if (result.denied.length === 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason,\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason,\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet email validation rule. Applying this rule allows you to validate &\n * verify an email address.\n *\n * The first step of the analysis is to validate the email address syntax. This\n * runs locally within the SDK and validates the email address is in the correct\n * format. If the email syntax is valid, the SDK will pass the email address to\n * the Arcjet cloud API to verify the email address. This performs several\n * checks, depending on the rule configuration.\n *\n * @param {EmailOptions} options - The options for the email validation rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block email addresses based on the\n * configuration, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetEmailType>} options.deny - The list of email types to\n * deny. If provided, the email types in this list will be denied. You may only\n * provide either `allow` or `deny`, not both. Specify one or more of the\n * following:\n *\n * - `\"DISPOSABLE\"` - Disposable email addresses.\n * - `\"FREE\"` - Free email addresses.\n * - `\"NO_MX_RECORDS\"` - Email addresses with no MX records.\n * - `\"NO_GRAVATAR\"` - Email addresses with no Gravatar.\n * - `\"INVALID\"` - Invalid email addresses.\n *\n * @param {Array<ArcjetEmailType>} options.allow - The list of email types to\n * allow. If provided, email addresses in this list will be allowed and all\n * others will be denied. You may only provide either `allow` or `deny`, not\n * both. The same options apply as for `deny`.\n * @returns {Primitive} The email rule to provide to the SDK in the `rules`\n * option.\n *\n * @example\n * ```ts\n * validateEmail({ mode: \"LIVE\", deny: [\"DISPOSABLE\", \"INVALID\"] });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     validateEmail({\n *       mode: \"LIVE\",\n *       deny: [\"DISPOSABLE\", \"INVALID\"]\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/email-validation/concepts\n * @link https://docs.arcjet.com/email-validation/reference\n */\nfunction validateEmail(options) {\n    validateEmailOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `allow` and `block` cannot be provided together\");\n    }\n    if (typeof options.deny !== \"undefined\" &&\n        typeof options.block !== \"undefined\") {\n        throw new Error(\"`validateEmail` options error: `deny` and `block` cannot be provided together, `block` is now deprecated so `deny` should be preferred.\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\" &&\n        typeof options.block === \"undefined\") {\n        throw new Error(\"`validateEmail` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"EMAIL\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? options.block ?? [];\n    const requireTopLevelDomain = options.requireTopLevelDomain ?? true;\n    const allowDomainLiteral = options.allowDomainLiteral ?? false;\n    const id = _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.stringSliceOrdered(\"deny\", deny), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.bool(\"requireTopLevelDomain\", requireTopLevelDomain), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.bool(\"allowDomainLiteral\", allowDomainLiteral));\n    let config = {\n        tag: \"deny-email-validation-config\",\n        val: {\n            requireTopLevelDomain,\n            allowDomainLiteral,\n            deny: [],\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allow-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                allow: options.allow,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.deny,\n            },\n        };\n    }\n    if (typeof options.block !== \"undefined\") {\n        config = {\n            tag: \"deny-email-validation-config\",\n            val: {\n                requireTopLevelDomain,\n                allowDomainLiteral,\n                deny: options.block,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.EmailValidation,\n        type,\n        mode,\n        allow,\n        deny,\n        requireTopLevelDomain,\n        allowDomainLiteral,\n        validate(context, details) {\n            assert(typeof details.email !== \"undefined\", \"ValidateEmail requires `email` to be set.\");\n        },\n        async protect(context, { email }) {\n            const ruleId = await id;\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.isValidEmail(context, email, config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            if (result.validity === \"valid\") {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({ emailTypes: [] }),\n                });\n            }\n            else {\n                const typedEmailTypes = result.blocked.filter(isEmailType);\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 0,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetEmailReason({\n                        emailTypes: typedEmailTypes,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet bot detection rule. Applying this rule allows you to manage traffic by\n * automated clients and bots.\n *\n * Bots can be good (such as search engine crawlers or monitoring agents) or bad\n * (such as scrapers or automated scripts). Arcjet allows you to configure which\n * bots you want to allow or deny by specific bot names e.g. curl, as well as by\n * category e.g. search engine bots.\n *\n * Bots are detected based on various signals such as the user agent, IP\n * address, DNS records, and more.\n *\n * @param {BotOptions} options - The options for the bot rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block detected bots, and `\"DRY_RUN\"`\n * will allow all requests while still providing access to the rule results.\n * Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.allow - The\n * list of bots to allow. If provided, only the bots in this list will be\n * allowed and any other detected bot will be denied. If empty, all bots will be\n * denied. You may only provide either `allow` or `deny`, not both. You can use\n * specific bots e.g. `\"CURL\"` will allow the default user-agent of the `curl`\n * tool. You can also use categories e.g. `\"CATEGORY:SEARCH_ENGINE\"` will allow\n * all search engine bots. See\n * https://docs.arcjet.com/bot-protection/identifying-bots for the full list of\n * bots and categories.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.deny - The\n * list of bots to deny. If provided, the bots in this list will be denied and\n * all other detected bots will be allowed. You may only provide either `allow`\n * or `deny`, not both. The same options apply as for `allow`.\n * @returns {Primitive} The bot rule to provide to the SDK in the `rules`\n * option.\n *\n * @example\n * Allows search engine bots and curl, denies all other bots\n *\n * ```ts\n * detectBot({ mode: \"LIVE\", allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"] });\n * ```\n * @example\n * Allows search engine bots and curl, denies all other bots\n *\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     detectBot({\n *       mode: \"LIVE\",\n *       allow: [\"CATEGORY:SEARCH_ENGINE\", \"CURL\"]\n *     })\n *   ],\n * });\n * ```\n * @example\n * Denies AI crawlers, allows all other bots\n *\n * ```ts\n * detectBot({ mode: \"LIVE\", deny: [\"CATEGORY:AI\"] });\n * ```\n * @example\n * Denies AI crawlers, allows all other bots\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *     detectBot({\n *       mode: \"LIVE\",\n *       deny: [\"CATEGORY:AI\"]\n *     })\n *   ],\n * });\n * ```\n * @link https://docs.arcjet.com/bot-protection/concepts\n * @link https://docs.arcjet.com/bot-protection/identifying-bots\n * @link https://docs.arcjet.com/bot-protection/reference\n */\nfunction detectBot(options) {\n    validateBotOptions(options);\n    if (typeof options.allow !== \"undefined\" &&\n        typeof options.deny !== \"undefined\") {\n        throw new Error(\"`detectBot` options error: `allow` and `deny` cannot be provided together\");\n    }\n    if (typeof options.allow === \"undefined\" &&\n        typeof options.deny === \"undefined\") {\n        throw new Error(\"`detectBot` options error: either `allow` or `deny` must be specified\");\n    }\n    const type = \"BOT\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const allow = options.allow ?? [];\n    const deny = options.deny ?? [];\n    const id = _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.hash(_arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.string(\"type\", type), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.uint32(\"version\", version), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.string(\"mode\", mode), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.stringSliceOrdered(\"allow\", allow), _arcjet_stable_hash__WEBPACK_IMPORTED_MODULE_6__.stringSliceOrdered(\"deny\", deny));\n    let config = {\n        tag: \"allowed-bot-config\",\n        val: {\n            entities: [],\n            skipCustomDetect: true,\n        },\n    };\n    if (typeof options.allow !== \"undefined\") {\n        config = {\n            tag: \"allowed-bot-config\",\n            val: {\n                entities: options.allow,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    if (typeof options.deny !== \"undefined\") {\n        config = {\n            tag: \"denied-bot-config\",\n            val: {\n                entities: options.deny,\n                skipCustomDetect: true,\n            },\n        };\n    }\n    const rule = {\n        version,\n        priority: Priority.BotDetection,\n        type,\n        mode,\n        allow,\n        deny,\n        validate(context, details) {\n            if (typeof details.headers === \"undefined\") {\n                throw new Error(\"bot detection requires `headers` to be set\");\n            }\n            if (typeof details.headers.has !== \"function\") {\n                throw new Error(\"bot detection requires `headers` to extend `Headers`\");\n            }\n            if (!details.headers.has(\"user-agent\")) {\n                throw new Error(\"bot detection requires user-agent header\");\n            }\n        },\n        /**\n         * Attempts to call the bot detection on the headers.\n         */\n        async protect(context, request) {\n            const ruleId = await id;\n            const result = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.detectBot(context, toAnalyzeRequest(request), config);\n            const state = mode === \"LIVE\" ? \"RUN\" : \"DRY_RUN\";\n            // If this is a bot and of a type that we want to block, then block!\n            if (result.denied.length > 0) {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 60,\n                    state,\n                    conclusion: \"DENY\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n            else {\n                return new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                    ruleId,\n                    ttl: 0,\n                    state,\n                    conclusion: \"ALLOW\",\n                    reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetBotReason({\n                        allowed: result.allowed,\n                        denied: result.denied,\n                        verified: result.verified,\n                        spoofed: result.spoofed,\n                    }),\n                });\n            }\n        },\n    };\n    return [rule];\n}\n/**\n * Arcjet Shield WAF rule. Applying this rule protects your application against\n * common attacks, including the OWASP Top 10.\n *\n * The Arcjet Shield WAF analyzes every request to your application to detect\n * suspicious activity. Once a certain suspicion threshold is reached,\n * subsequent requests from that client are blocked for a period of time.\n *\n * @param {ShieldOptions} options - The options for the Shield rule.\n * @param {ArcjetMode} options.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block suspicious requests, and\n * `\"DRY_RUN\"` will allow all requests while still providing access to the rule\n * results. Defaults to `\"DRY_RUN\"` if not specified.\n * @returns {Primitive} The Shield rule to provide to the SDK in the `rules`\n * option.\n *\n * @example\n * ```ts\n * shield({ mode: \"LIVE\" });\n * ```\n * @example\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [shield({ mode: \"LIVE\" })],\n * });\n * ```\n * @link https://docs.arcjet.com/shield/concepts\n * @link https://docs.arcjet.com/shield/reference\n */\nfunction shield(options) {\n    validateShieldOptions(options);\n    const type = \"SHIELD\";\n    const version = 0;\n    const mode = options.mode === \"LIVE\" ? \"LIVE\" : \"DRY_RUN\";\n    const rule = {\n        type,\n        version,\n        priority: Priority.Shield,\n        mode,\n    };\n    return [rule];\n}\n/**\n * Arcjet signup form protection rule. Applying this rule combines rate\n * limiting, bot protection, and email validation to protect your signup forms\n * from abuse. Using this rule will configure the following:\n *\n * - Rate limiting - signup forms are a common target for bots. Arcjets rate\n *   limiting helps to prevent bots and other automated or malicious clients\n *   from submitting your signup form too many times in a short period of time.\n * - Bot protection - signup forms are usually exclusively used by humans, which\n *   means that any automated submissions to the form are likely to be\n *   fraudulent.\n * - Email validation - email addresses should be validated to ensure the signup\n *   is coming from a legitimate user with a real email address that can\n *   actually receive messages.\n *\n * @param {ProtectSignupOptions} options - The options for the signup form\n * protection rule.\n * @param {ArcjetMode} options.email.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block email addresses based on the\n * configuration, and `\"DRY_RUN\"` will allow all requests while still providing\n * access to the rule results. Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetEmailType>} options.email.deny - The list of email types\n * to deny. If provided, the email types in this list will be denied. You may\n * only provide either `allow` or `deny`, not both. Specify one or more of the\n * following:\n *\n * - `\"DISPOSABLE\"` - Disposable email addresses.\n * - `\"FREE\"` - Free email addresses.\n * - `\"NO_MX_RECORDS\"` - Email addresses with no MX records.\n * - `\"NO_GRAVATAR\"` - Email addresses with no Gravatar.\n * - `\"INVALID\"` - Invalid email addresses.\n *\n * @param {Array<ArcjetEmailType>} options.email.allow - The list of email types\n * to allow. If provided, email addresses in this list will be allowed and all\n * others will be denied. You may only provide either `allow` or `deny`, not\n * both. The same options apply as for `deny`.\n * @param {ArcjetMode} options.bots.mode - The block mode of the rule, either\n * `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block detected bots, and `\"DRY_RUN\"`\n * will allow all requests while still providing access to the rule results.\n * Defaults to `\"DRY_RUN\"` if not specified.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.bots.allow -\n * The list of bots to allow. If provided, only the bots in this list will be\n * allowed and any other detected bot will be denied. If empty, all bots will be\n * denied. You may only provide either `allow` or `deny`, not both. You can use\n * specific bots e.g. `\"CURL\"` will allow the default user-agent of the `curl`\n * tool. You can also use categories e.g. `\"CATEGORY:SEARCH_ENGINE\"` will allow\n * all search engine bots. See\n * https://docs.arcjet.com/bot-protection/identifying-bots for the full list of\n * bots and categories.\n * @param {Array<ArcjetWellKnownBot | ArcjetBotCategory>} options.bots.deny -\n * The list of bots to deny. If provided, the bots in this list will be denied\n * and all other detected bots will be allowed. You may only provide either\n * `allow` or `deny`, not both. The same options apply as for `allow`.\n * @param {SlidingWindowRateLimitOptions} options.rateLimit - The options for\n * the sliding window rate limiting rule.\n * @param {ArcjetMode} options.rateLimit.mode - The block mode of the rule,\n * either `\"LIVE\"` or `\"DRY_RUN\"`. `\"LIVE\"` will block requests when the rate\n * limit is exceeded, and `\"DRY_RUN\"` will allow all requests while still\n * providing access to the rule results. Defaults to `\"DRY_RUN\"` if not\n * specified.\n * @param {string | number} options.rateLimit.interval - The time interval for\n * the rate limit. This can be a string like `\"60s\"` for 60 seconds, `\"1h45m\"`\n * for 1 hour and 45 minutes, or a number like `60` for 60 seconds. Valid string\n * time units are:\n * - `s` for seconds.\n * - `m` for minutes.\n * - `h` for hours.\n * - `d` for days.\n * @param {number} options.rateLimit.max - The maximum number of requests\n * allowed in the sliding time window.\n * @returns {Primitive} The signup form protection rule to provide to the SDK in\n * the `rules` option.\n *\n * @example\n * Our recommended configuration for most signup forms is:\n *\n * - Block emails with invalid syntax, that are from disposable email providers,\n *   or do not have valid MX records configured.\n * - Block all bots.\n * - Apply a rate limit of 5 submissions per 10 minutes from a single IP\n *   address.\n *\n * ```ts\n * const aj = arcjet({\n *   key: process.env.ARCJET_KEY,\n *   rules: [\n *    protectSignup({\n *      email: {\n *        mode: \"LIVE\",\n *        block: [\"DISPOSABLE\", \"INVALID\", \"NO_MX_RECORDS\"],\n *      },\n *      bots: {\n *        mode: \"LIVE\",\n *        allow: [], // block all detected bots\n *      },\n *      rateLimit: {\n *        mode: \"LIVE\",\n *        interval: \"10m\",\n *        max: 5,\n *      },\n *    }),\n *  ],\n * });\n * ```\n * @link https://docs.arcjet.com/signup-protection/concepts\n * @link https://docs.arcjet.com/signup-protection/reference\n */\nfunction protectSignup(options) {\n    return [\n        ...slidingWindow(options.rateLimit),\n        ...detectBot(options.bots),\n        ...validateEmail(options.email),\n    ];\n}\n/**\n * Create a new Arcjet client with the specified {@link ArcjetOptions}.\n *\n * @param options {ArcjetOptions} Arcjet configuration options.\n */\nfunction arcjet(options) {\n    // We destructure here to make the function signature neat when viewed by consumers\n    const { key, rules } = options;\n    const rt = (0,_arcjet_runtime__WEBPACK_IMPORTED_MODULE_5__.runtime)();\n    // TODO: Separate the ArcjetOptions from the SDK Options\n    // It is currently optional in the options so users can override it via an SDK\n    if (typeof options.log === \"undefined\") {\n        throw new Error(\"Log is required\");\n    }\n    const log = options.log;\n    const perf = new Performance(log);\n    // TODO(#207): Remove this when we can default the transport so client is not required\n    // It is currently optional in the options so the Next SDK can override it for the user\n    if (typeof options.client === \"undefined\") {\n        throw new Error(\"Client is required\");\n    }\n    const client = options.client;\n    // A local cache of block decisions. Might be emphemeral per request,\n    // depending on the way the runtime works, but it's worth a try.\n    // TODO(#132): Support configurable caching\n    const blockCache = new Cache();\n    const rootRules = rules\n        .flat(1)\n        .sort((a, b) => a.priority - b.priority);\n    async function protect(rules, ctx, request) {\n        // This goes against the type definition above, but users might call\n        // `protect()` with no value and we don't want to crash\n        if (typeof request === \"undefined\") {\n            request = {};\n        }\n        const details = Object.freeze({\n            ip: request.ip,\n            method: request.method,\n            protocol: request.protocol,\n            host: request.host,\n            path: request.path,\n            headers: new _arcjet_headers__WEBPACK_IMPORTED_MODULE_4__[\"default\"](request.headers),\n            cookies: request.cookies,\n            query: request.query,\n            // TODO(#208): Re-add body\n            // body: request.body,\n            extra: extraProps(request),\n            email: typeof request.email === \"string\" ? request.email : undefined,\n        });\n        const characteristics = options.characteristics\n            ? [...options.characteristics]\n            : [];\n        const waitUntil = lookupWaitUntil();\n        const baseContext = {\n            key,\n            log,\n            characteristics,\n            waitUntil,\n            ...ctx,\n        };\n        let fingerprint = \"\";\n        const logFingerprintPerf = perf.measure(\"fingerprint\");\n        try {\n            fingerprint = await _arcjet_analyze__WEBPACK_IMPORTED_MODULE_2__.generateFingerprint(baseContext, toAnalyzeRequest(details));\n            log.debug(\"fingerprint (%s): %s\", rt, fingerprint);\n        }\n        catch (error) {\n            log.error({ error }, \"Failed to build fingerprint. Please verify your Characteristics.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(`Failed to build fingerprint - ${errorMessage(error)}`),\n                // No results because we couldn't create a fingerprint\n                results: [],\n            });\n            // TODO: Consider sending this to Report when we have an infallible fingerprint\n            return decision;\n        }\n        finally {\n            logFingerprintPerf();\n        }\n        const context = Object.freeze({\n            ...baseContext,\n            fingerprint,\n            runtime: rt,\n        });\n        if (rules.length < 1) {\n            log.warn(\"Calling `protect()` with no rules is deprecated. Did you mean to configure the Shield rule?\");\n        }\n        if (rules.length > 10) {\n            log.error(\"Failure running rules. Only 10 rules may be specified.\");\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"Only 10 rules may be specified\"),\n                // No results because the sorted rules were too long and we don't want\n                // to instantiate a ton of NOT_RUN results\n                results: [],\n            });\n            client.report(context, details, decision, \n            // No rules because we've determined they were too long and we don't\n            // want to try to send them to the server\n            []);\n            return decision;\n        }\n        const results = [];\n        for (let idx = 0; idx < rules.length; idx++) {\n            // Default all rules to NOT_RUN/ALLOW before doing anything\n            results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                // TODO(#4030): Figure out if we can get each Rule ID before they are run\n                ruleId: \"\",\n                ttl: 0,\n                state: \"NOT_RUN\",\n                conclusion: \"ALLOW\",\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetReason(),\n            });\n            // Add top-level characteristics to all Rate Limit rules that don't already have\n            // their own set of characteristics.\n            const candidate_rule = rules[idx];\n            if ((0,_arcjet_protocol_convert_js__WEBPACK_IMPORTED_MODULE_1__.isRateLimitRule)(candidate_rule)) {\n                if (typeof candidate_rule.characteristics === \"undefined\") {\n                    candidate_rule.characteristics = characteristics;\n                    rules[idx] = candidate_rule;\n                }\n            }\n        }\n        const logLocalPerf = perf.measure(\"local\");\n        try {\n            // We have our own local cache which we check first. This doesn't work in\n            // serverless environments where every request is isolated, but there may be\n            // some instances where the instance is not recycled immediately. If so, we\n            // can take advantage of that.\n            const logCachePerf = perf.measure(\"cache\");\n            const existingBlockReason = blockCache.get(fingerprint);\n            logCachePerf();\n            // If already blocked then we can async log to the API and return the\n            // decision immediately.\n            if (existingBlockReason) {\n                const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                    ttl: blockCache.ttl(fingerprint),\n                    reason: existingBlockReason,\n                    // All results will be NOT_RUN because we used a cached decision\n                    results,\n                });\n                client.report(context, details, decision, rules);\n                log.debug({\n                    id: decision.id,\n                    conclusion: decision.conclusion,\n                    fingerprint,\n                    reason: existingBlockReason,\n                    runtime: rt,\n                }, \"decide: already blocked\");\n                return decision;\n            }\n            for (const [idx, rule] of rules.entries()) {\n                // This re-assignment is a workaround to a TypeScript error with\n                // assertions where the name was introduced via a destructure\n                let localRule;\n                if (isLocalRule(rule)) {\n                    localRule = rule;\n                }\n                else {\n                    continue;\n                }\n                const logRulePerf = perf.measure(rule.type);\n                try {\n                    localRule.validate(context, details);\n                    results[idx] = await localRule.protect(context, details);\n                    // If a rule didn't return a rule result, we need to stub it to avoid\n                    // crashing. This should only happen if a user writes a custom local\n                    // rule incorrectly.\n                    if (typeof results[idx] === \"undefined\") {\n                        results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                            // TODO(#4030): If we can get the Rule ID before running rules,\n                            // this can use it\n                            ruleId: \"\",\n                            ttl: 0,\n                            state: \"RUN\",\n                            conclusion: \"ERROR\",\n                            reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(\"rule result missing\"),\n                        });\n                    }\n                    log.debug({\n                        id: results[idx].ruleId,\n                        rule: rule.type,\n                        fingerprint,\n                        path: details.path,\n                        runtime: rt,\n                        ttl: results[idx].ttl,\n                        conclusion: results[idx].conclusion,\n                        reason: results[idx].reason,\n                    }, \"Local rule result:\");\n                }\n                catch (err) {\n                    log.error(\"Failure running rule: %s due to %s\", rule.type, errorMessage(err));\n                    results[idx] = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetRuleResult({\n                        // TODO(#4030): Figure out if we can get a Rule ID in this error case\n                        ruleId: \"\",\n                        ttl: 0,\n                        state: \"RUN\",\n                        conclusion: \"ERROR\",\n                        reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                    });\n                }\n                finally {\n                    logRulePerf();\n                }\n                if (results[idx].isDenied()) {\n                    // If the rule is not a DRY_RUN, we want to cache non-zero TTL results\n                    // and return a DENY decision.\n                    if (results[idx].state !== \"DRY_RUN\") {\n                        const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetDenyDecision({\n                            ttl: results[idx].ttl,\n                            reason: results[idx].reason,\n                            results,\n                        });\n                        // Only a DENY decision is reported to avoid creating 2 entries for\n                        // a request. Upon ALLOW, the `decide` call will create an entry for\n                        // the request.\n                        client.report(context, details, decision, rules);\n                        if (results[idx].ttl > 0) {\n                            log.debug({\n                                fingerprint,\n                                conclusion: decision.conclusion,\n                                reason: decision.reason,\n                            }, \"Caching decision for %d seconds\", decision.ttl);\n                            blockCache.set(fingerprint, decision.reason, nowInSeconds() + decision.ttl);\n                        }\n                        return decision;\n                    }\n                    log.warn(`Dry run mode is enabled for \"%s\" rule. Overriding decision. Decision was: DENY`, rule.type);\n                }\n            }\n        }\n        finally {\n            logLocalPerf();\n        }\n        // With no cached values, we take a decision remotely. We use a timeout to\n        // fail open.\n        const logRemotePerf = perf.measure(\"remote\");\n        try {\n            const logDediceApiPerf = perf.measure(\"decideApi\");\n            const decision = await client\n                .decide(context, details, rules)\n                .finally(() => {\n                logDediceApiPerf();\n            });\n            // If the decision is to block and we have a non-zero TTL, we cache the\n            // block locally\n            if (decision.isDenied() && decision.ttl > 0) {\n                log.debug(\"decide: Caching block locally for %d seconds\", decision.ttl);\n                blockCache.set(fingerprint, decision.reason, nowInSeconds() + decision.ttl);\n            }\n            return decision;\n        }\n        catch (err) {\n            log.error(\"Encountered problem getting remote decision: %s\", errorMessage(err));\n            const decision = new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorDecision({\n                ttl: 0,\n                reason: new _arcjet_protocol__WEBPACK_IMPORTED_MODULE_0__.ArcjetErrorReason(err),\n                results,\n            });\n            client.report(context, details, decision, rules);\n            return decision;\n        }\n        finally {\n            logRemotePerf();\n        }\n    }\n    // This is a separate function so it can be called recursively\n    function withRule(baseRules, rule) {\n        const rules = [...baseRules, ...rule].sort((a, b) => a.priority - b.priority);\n        return Object.freeze({\n            withRule(rule) {\n                return withRule(rules, rule);\n            },\n            async protect(ctx, request) {\n                return protect(rules, ctx, request);\n            },\n        });\n    }\n    return Object.freeze({\n        withRule(rule) {\n            return withRule(rootRules, rule);\n        },\n        async protect(ctx, request) {\n            return protect(rootRules, ctx, request);\n        },\n    });\n}\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Q0E7QUFDQSw2Q0FBNkMsZ0VBQWtCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxpRUFBbUI7QUFDcEQ7QUFDQSw0QkFBNEIsK0RBQWlCO0FBQzdDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVzSSIsInNvdXJjZXMiOlsid2VicGFjazovL2ZpbmFuY2UtcGxhdGZvcm0vLi9ub2RlX21vZHVsZXMvYXJjamV0L2luZGV4LmpzP2QyYjEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXJjamV0RXJyb3JEZWNpc2lvbiwgQXJjamV0RXJyb3JSZWFzb24sIEFyY2pldFJ1bGVSZXN1bHQsIEFyY2pldFJlYXNvbiwgQXJjamV0RGVueURlY2lzaW9uLCBBcmNqZXRCb3RSZWFzb24sIEFyY2pldEVtYWlsUmVhc29uLCBBcmNqZXRTZW5zaXRpdmVJbmZvUmVhc29uIH0gZnJvbSAnQGFyY2pldC9wcm90b2NvbCc7XG5leHBvcnQgKiBmcm9tICdAYXJjamV0L3Byb3RvY29sJztcbmltcG9ydCB7IGlzUmF0ZUxpbWl0UnVsZSB9IGZyb20gJ0BhcmNqZXQvcHJvdG9jb2wvY29udmVydC5qcyc7XG5pbXBvcnQgKiBhcyBhbmFseXplIGZyb20gJ0BhcmNqZXQvYW5hbHl6ZSc7XG5pbXBvcnQgKiBhcyBkdXJhdGlvbiBmcm9tICdAYXJjamV0L2R1cmF0aW9uJztcbmltcG9ydCBBcmNqZXRIZWFkZXJzIGZyb20gJ0BhcmNqZXQvaGVhZGVycyc7XG5pbXBvcnQgeyBydW50aW1lIH0gZnJvbSAnQGFyY2pldC9ydW50aW1lJztcbmltcG9ydCAqIGFzIGhhc2hlciBmcm9tICdAYXJjamV0L3N0YWJsZS1oYXNoJztcblxuZnVuY3Rpb24gYXNzZXJ0KGNvbmRpdGlvbiwgbXNnKSB7XG4gICAgaWYgKCFjb25kaXRpb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbm93SW5TZWNvbmRzKCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKERhdGUubm93KCkgLyAxMDAwKTtcbn1cbmNsYXNzIENhY2hlIHtcbiAgICBleHBpcmVzO1xuICAgIGRhdGE7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuZXhwaXJlcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5kYXRhID0gbmV3IE1hcCgpO1xuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIGNvbnN0IHR0bCA9IHRoaXMudHRsKGtleSk7XG4gICAgICAgIGlmICh0dGwgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kYXRhLmdldChrZXkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ2xlYW51cCBpZiBleHBpcmVkXG4gICAgICAgICAgICB0aGlzLmV4cGlyZXMuZGVsZXRlKGtleSk7XG4gICAgICAgICAgICB0aGlzLmRhdGEuZGVsZXRlKGtleSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0KGtleSwgdmFsdWUsIGV4cGlyZXNBdCkge1xuICAgICAgICB0aGlzLmV4cGlyZXMuc2V0KGtleSwgZXhwaXJlc0F0KTtcbiAgICAgICAgdGhpcy5kYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgdHRsKGtleSkge1xuICAgICAgICBjb25zdCBub3cgPSBub3dJblNlY29uZHMoKTtcbiAgICAgICAgY29uc3QgZXhwaXJlc0F0ID0gdGhpcy5leHBpcmVzLmdldChrZXkpID8/IG5vdztcbiAgICAgICAgcmV0dXJuIGV4cGlyZXNBdCAtIG5vdztcbiAgICB9XG59XG5mdW5jdGlvbiBlcnJvck1lc3NhZ2UoZXJyKSB7XG4gICAgaWYgKGVycikge1xuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVyciA9PT0gXCJvYmplY3RcIiAmJlxuICAgICAgICAgICAgXCJtZXNzYWdlXCIgaW4gZXJyICYmXG4gICAgICAgICAgICB0eXBlb2YgZXJyLm1lc3NhZ2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBlcnIubWVzc2FnZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gXCJVbmtub3duIHByb2JsZW1cIjtcbn1cbmNvbnN0IGtub3duRmllbGRzID0gW1xuICAgIFwiaXBcIixcbiAgICBcIm1ldGhvZFwiLFxuICAgIFwicHJvdG9jb2xcIixcbiAgICBcImhvc3RcIixcbiAgICBcInBhdGhcIixcbiAgICBcImhlYWRlcnNcIixcbiAgICBcImJvZHlcIixcbiAgICBcImVtYWlsXCIsXG4gICAgXCJjb29raWVzXCIsXG4gICAgXCJxdWVyeVwiLFxuXTtcbmZ1bmN0aW9uIGlzVW5rbm93blJlcXVlc3RQcm9wZXJ0eShrZXkpIHtcbiAgICByZXR1cm4gIWtub3duRmllbGRzLmluY2x1ZGVzKGtleSk7XG59XG5mdW5jdGlvbiBpc0VtYWlsVHlwZSh0eXBlKSB7XG4gICAgcmV0dXJuICh0eXBlID09PSBcIkZSRUVcIiB8fFxuICAgICAgICB0eXBlID09PSBcIkRJU1BPU0FCTEVcIiB8fFxuICAgICAgICB0eXBlID09PSBcIk5PX01YX1JFQ09SRFNcIiB8fFxuICAgICAgICB0eXBlID09PSBcIk5PX0dSQVZBVEFSXCIgfHxcbiAgICAgICAgdHlwZSA9PT0gXCJJTlZBTElEXCIpO1xufVxuY2xhc3MgUGVyZm9ybWFuY2Uge1xuICAgIGxvZztcbiAgICBjb25zdHJ1Y3Rvcihsb2dnZXIpIHtcbiAgICAgICAgdGhpcy5sb2cgPSBsb2dnZXI7XG4gICAgfVxuICAgIC8vIFRPRE8oIzIwMjApOiBXZSBzaG91bGQgbm8tb3AgdGhpcyBpZiBsb2dsZXZlbCBpcyBub3QgYGRlYnVnYCB0byBkbyBsZXNzIHdvcmtcbiAgICBtZWFzdXJlKGxhYmVsKSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICAgICAgICAgIGNvbnN0IGRpZmYgPSBlbmQgLSBzdGFydDtcbiAgICAgICAgICAgIHRoaXMubG9nLmRlYnVnKFwiTEFURU5DWSAlczogJXNtc1wiLCBsYWJlbCwgZGlmZi50b0ZpeGVkKDMpKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiB0b1N0cmluZyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gdmFsdWUgPyBcInRydWVcIiA6IFwiZmFsc2VcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiPHVuc3VwcG9ydGVkIHZhbHVlPlwiO1xufVxuLy8gVGhpcyBpcyB0aGUgU3ltYm9sIHRoYXQgVmVyY2VsIGRlZmluZXMgaW4gdGhlaXIgaW5mcmFzdHJ1Y3R1cmUgdG8gYWNjZXNzIHRoZVxuLy8gQ29udGV4dCAod2hlcmUgYXZhaWxhYmxlKS4gVGhlIENvbnRleHQgY2FuIGNvbnRhaW4gdGhlIGB3YWl0VW50aWxgIGZ1bmN0aW9uLlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL3ZlcmNlbC92ZXJjZWwvYmxvYi85MzBkN2ZiODkyZGMyNmYyNDBmMmI5NTBkOTYzOTMxYzQ1ZTFlNjYxL3BhY2thZ2VzL2Z1bmN0aW9ucy9zcmMvZ2V0LWNvbnRleHQudHMjTDZcbmNvbnN0IFNZTUJPTF9GT1JfUkVRX0NPTlRFWFQgPSBTeW1ib2wuZm9yKFwiQHZlcmNlbC9yZXF1ZXN0LWNvbnRleHRcIik7XG5mdW5jdGlvbiBsb29rdXBXYWl0VW50aWwoKSB7XG4gICAgY29uc3QgZnJvbVN5bWJvbCA9IGdsb2JhbFRoaXM7XG4gICAgaWYgKHR5cGVvZiBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgIGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0gIT09IG51bGwgJiZcbiAgICAgICAgXCJnZXRcIiBpbiBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdICYmXG4gICAgICAgIHR5cGVvZiBmcm9tU3ltYm9sW1NZTUJPTF9GT1JfUkVRX0NPTlRFWFRdLmdldCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHZlcmNlbEN0eCA9IGZyb21TeW1ib2xbU1lNQk9MX0ZPUl9SRVFfQ09OVEVYVF0uZ2V0KCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmVyY2VsQ3R4ID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICB2ZXJjZWxDdHggIT09IG51bGwgJiZcbiAgICAgICAgICAgIFwid2FpdFVudGlsXCIgaW4gdmVyY2VsQ3R4ICYmXG4gICAgICAgICAgICB0eXBlb2YgdmVyY2VsQ3R4LndhaXRVbnRpbCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmVyY2VsQ3R4LndhaXRVbnRpbDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHRvQW5hbHl6ZVJlcXVlc3QocmVxdWVzdCkge1xuICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICBpZiAodHlwZW9mIHJlcXVlc3QuaGVhZGVycyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiByZXF1ZXN0LmhlYWRlcnMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAuLi5yZXF1ZXN0LFxuICAgICAgICBoZWFkZXJzLFxuICAgIH07XG59XG5mdW5jdGlvbiBleHRyYVByb3BzKGRldGFpbHMpIHtcbiAgICBjb25zdCBleHRyYSA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkZXRhaWxzKSkge1xuICAgICAgICBpZiAoaXNVbmtub3duUmVxdWVzdFByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGV4dHJhLnNldChrZXksIHRvU3RyaW5nKHZhbHVlKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhleHRyYS5lbnRyaWVzKCkpO1xufVxuZnVuY3Rpb24gY3JlYXRlVHlwZVZhbGlkYXRvciguLi50eXBlcykge1xuICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCB0eXBlT2ZWYWx1ZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgICAgaWYgKCF0eXBlcy5pbmNsdWRlcyh0eXBlT2ZWYWx1ZSkpIHtcbiAgICAgICAgICAgIGlmICh0eXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGludmFsaWQgdHlwZSBmb3IgXFxgJHtrZXl9XFxgIC0gZXhwZWN0ZWQgJHt0eXBlc1swXX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgaW52YWxpZCB0eXBlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCBvbmUgb2YgJHt0eXBlcy5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmFsdWVWYWxpZGF0b3IoXG4vLyBUaGlzIHVzZXMgdHlwZXMgdG8gZW5zdXJlIHdlIGhhdmUgYXQgbGVhc3QgMiB2YWx1ZXNcbi4uLnZhbHVlcykge1xuICAgIHJldHVybiAoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAvLyBXZSBjYXN0IHRoZSB2YWx1ZXMgdG8gdW5rbm93biBiZWNhdXNlIHRoZSBvcHRpb25WYWx1ZSBpc24ndCBrbm93biBidXRcbiAgICAgICAgLy8gd2Ugb25seSB3YW50IHRvIHVzZSBgdmFsdWVzYCBvbiBzdHJpbmcgZW51bWVyYXRpb25zXG4gICAgICAgIGlmICghdmFsdWVzLmluY2x1ZGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHZhbHVlIGZvciBcXGAke2tleX1cXGAgLSBleHBlY3RlZCBvbmUgb2YgJHt2YWx1ZXMubWFwKCh2YWx1ZSkgPT4gYCcke3ZhbHVlfSdgKS5qb2luKFwiLCBcIil9YCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQXJyYXlWYWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgICByZXR1cm4gKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIGl0ZW1dIG9mIHZhbHVlLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIHZhbGlkYXRlKGAke2tleX1bJHtpZHh9XWAsIGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIHR5cGUgZm9yIFxcYCR7a2V5fVxcYCAtIGV4cGVjdGVkIGFuIGFycmF5YCk7XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRhdG9yKHsgcnVsZSwgdmFsaWRhdGlvbnMsIH0pIHtcbiAgICByZXR1cm4gKG9wdGlvbnMpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCB7IGtleSwgdmFsaWRhdGUsIHJlcXVpcmVkIH0gb2YgdmFsaWRhdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChyZXF1aXJlZCAmJiAhT2JqZWN0Lmhhc093bihvcHRpb25zLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke3J1bGV9XFxgIG9wdGlvbnMgZXJyb3I6IFxcYCR7a2V5fVxcYCBpcyByZXF1aXJlZGApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgICAvLyBUaGUgYHJlcXVpcmVkYCBmbGFnIGlzIGNoZWNrZWQgYWJvdmUsIHNvIHRoZXNlIHNob3VsZCBvbmx5IGJlIHZhbGlkYXRlZFxuICAgICAgICAgICAgLy8gaWYgdGhlIHZhbHVlIGlzIG5vdCB1bmRlZmluZWQuXG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGUoa2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcXGAke3J1bGV9XFxgIG9wdGlvbnMgZXJyb3I6ICR7ZXJyb3JNZXNzYWdlKGVycil9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmNvbnN0IHZhbGlkYXRlU3RyaW5nID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcInN0cmluZ1wiKTtcbmNvbnN0IHZhbGlkYXRlTnVtYmVyID0gY3JlYXRlVHlwZVZhbGlkYXRvcihcIm51bWJlclwiKTtcbmNvbnN0IHZhbGlkYXRlQm9vbGVhbiA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJib29sZWFuXCIpO1xuY29uc3QgdmFsaWRhdGVGdW5jdGlvbiA9IGNyZWF0ZVR5cGVWYWxpZGF0b3IoXCJmdW5jdGlvblwiKTtcbmNvbnN0IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgPSBjcmVhdGVUeXBlVmFsaWRhdG9yKFwic3RyaW5nXCIsIFwibnVtYmVyXCIpO1xuY29uc3QgdmFsaWRhdGVTdHJpbmdBcnJheSA9IGNyZWF0ZUFycmF5VmFsaWRhdG9yKHZhbGlkYXRlU3RyaW5nKTtcbmNvbnN0IHZhbGlkYXRlTW9kZSA9IGNyZWF0ZVZhbHVlVmFsaWRhdG9yKFwiTElWRVwiLCBcIkRSWV9SVU5cIik7XG5jb25zdCB2YWxpZGF0ZUVtYWlsVHlwZXMgPSBjcmVhdGVBcnJheVZhbGlkYXRvcihjcmVhdGVWYWx1ZVZhbGlkYXRvcihcIkRJU1BPU0FCTEVcIiwgXCJGUkVFXCIsIFwiTk9fTVhfUkVDT1JEU1wiLCBcIk5PX0dSQVZBVEFSXCIsIFwiSU5WQUxJRFwiKSk7XG5jb25zdCB2YWxpZGF0ZVRva2VuQnVja2V0T3B0aW9ucyA9IGNyZWF0ZVZhbGlkYXRvcih7XG4gICAgcnVsZTogXCJ0b2tlbkJ1Y2tldFwiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJtb2RlXCIsXG4gICAgICAgICAgICByZXF1aXJlZDogZmFsc2UsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBrZXk6IFwicmVmaWxsUmF0ZVwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgICAgIHsga2V5OiBcImludGVydmFsXCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdPck51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJjYXBhY2l0eVwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlTnVtYmVyIH0sXG4gICAgXSxcbn0pO1xuY29uc3QgdmFsaWRhdGVGaXhlZFdpbmRvd09wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwiZml4ZWRXaW5kb3dcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IFwiY2hhcmFjdGVyaXN0aWNzXCIsXG4gICAgICAgICAgICB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSxcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBrZXk6IFwibWF4XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVOdW1iZXIgfSxcbiAgICAgICAgeyBrZXk6IFwid2luZG93XCIsIHJlcXVpcmVkOiB0cnVlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdPck51bWJlciB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlU2xpZGluZ1dpbmRvd09wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwic2xpZGluZ1dpbmRvd1wiLFxuICAgIHZhbGlkYXRpb25zOiBbXG4gICAgICAgIHsga2V5OiBcIm1vZGVcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVNb2RlIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJjaGFyYWN0ZXJpc3RpY3NcIixcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5LFxuICAgICAgICAgICAgcmVxdWlyZWQ6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgICB7IGtleTogXCJtYXhcIiwgcmVxdWlyZWQ6IHRydWUsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJpbnRlcnZhbFwiLCByZXF1aXJlZDogdHJ1ZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nT3JOdW1iZXIgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZVNlbnNpdGl2ZUluZm9PcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInNlbnNpdGl2ZUluZm9cIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7IGtleTogXCJhbGxvd1wiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZVN0cmluZ0FycmF5IH0sXG4gICAgICAgIHsga2V5OiBcImRlbnlcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJjb250ZXh0V2luZG93U2l6ZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU51bWJlciB9LFxuICAgICAgICB7IGtleTogXCJkZXRlY3RcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVGdW5jdGlvbiB9LFxuICAgIF0sXG59KTtcbmNvbnN0IHZhbGlkYXRlRW1haWxPcHRpb25zID0gY3JlYXRlVmFsaWRhdG9yKHtcbiAgICBydWxlOiBcInZhbGlkYXRlRW1haWxcIixcbiAgICB2YWxpZGF0aW9uczogW1xuICAgICAgICB7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9LFxuICAgICAgICB7IGtleTogXCJibG9ja1wiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZUVtYWlsVHlwZXMgfSxcbiAgICAgICAgeyBrZXk6IFwiYWxsb3dcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVFbWFpbFR5cGVzIH0sXG4gICAgICAgIHsga2V5OiBcImRlbnlcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVFbWFpbFR5cGVzIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleTogXCJyZXF1aXJlVG9wTGV2ZWxEb21haW5cIixcbiAgICAgICAgICAgIHJlcXVpcmVkOiBmYWxzZSxcbiAgICAgICAgICAgIHZhbGlkYXRlOiB2YWxpZGF0ZUJvb2xlYW4sXG4gICAgICAgIH0sXG4gICAgICAgIHsga2V5OiBcImFsbG93RG9tYWluTGl0ZXJhbFwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZUJvb2xlYW4gfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZUJvdE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwiZGV0ZWN0Qm90XCIsXG4gICAgdmFsaWRhdGlvbnM6IFtcbiAgICAgICAgeyBrZXk6IFwibW9kZVwiLCByZXF1aXJlZDogZmFsc2UsIHZhbGlkYXRlOiB2YWxpZGF0ZU1vZGUgfSxcbiAgICAgICAgeyBrZXk6IFwiYWxsb3dcIiwgcmVxdWlyZWQ6IGZhbHNlLCB2YWxpZGF0ZTogdmFsaWRhdGVTdHJpbmdBcnJheSB9LFxuICAgICAgICB7IGtleTogXCJkZW55XCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlU3RyaW5nQXJyYXkgfSxcbiAgICBdLFxufSk7XG5jb25zdCB2YWxpZGF0ZVNoaWVsZE9wdGlvbnMgPSBjcmVhdGVWYWxpZGF0b3Ioe1xuICAgIHJ1bGU6IFwic2hpZWxkXCIsXG4gICAgdmFsaWRhdGlvbnM6IFt7IGtleTogXCJtb2RlXCIsIHJlcXVpcmVkOiBmYWxzZSwgdmFsaWRhdGU6IHZhbGlkYXRlTW9kZSB9XSxcbn0pO1xuY29uc3QgUHJpb3JpdHkgPSB7XG4gICAgU2Vuc2l0aXZlSW5mbzogMSxcbiAgICBTaGllbGQ6IDIsXG4gICAgUmF0ZUxpbWl0OiAzLFxuICAgIEJvdERldGVjdGlvbjogNCxcbiAgICBFbWFpbFZhbGlkYXRpb246IDUsXG59O1xuZnVuY3Rpb24gaXNMb2NhbFJ1bGUocnVsZSkge1xuICAgIHJldHVybiAoXCJ2YWxpZGF0ZVwiIGluIHJ1bGUgJiZcbiAgICAgICAgdHlwZW9mIHJ1bGUudmFsaWRhdGUgPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBcInByb3RlY3RcIiBpbiBydWxlICYmXG4gICAgICAgIHR5cGVvZiBydWxlLnByb3RlY3QgPT09IFwiZnVuY3Rpb25cIik7XG59XG4vKipcbiAqIEFyY2pldCB0b2tlbiBidWNrZXQgcmF0ZSBsaW1pdGluZyBydWxlLiBBcHBseWluZyB0aGlzIHJ1bGUgc2V0cyBhIHRva2VuXG4gKiBidWNrZXQgcmF0ZSBsaW1pdC5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyBiYXNlZCBvbiBhIGJ1Y2tldCBmaWxsZWQgd2l0aCBhIHNwZWNpZmljIG51bWJlciBvZiB0b2tlbnMuXG4gKiBFYWNoIHJlcXVlc3Qgd2l0aGRyYXdzIHNvbWUgYW1vdW50IG9mIHRva2VucyBmcm9tIHRoZSBidWNrZXQgYW5kIHRoZSBidWNrZXRcbiAqIGlzIHJlZmlsbGVkIGF0IGEgZml4ZWQgcmF0ZS4gT25jZSB0aGUgYnVja2V0IGlzIGVtcHR5LCB0aGUgY2xpZW50IGlzIGJsb2NrZWRcbiAqIHVudGlsIHRoZSBidWNrZXQgcmVmaWxscy5cbiAqXG4gKiBUaGlzIGFsZ29yaXRobSBpcyB1c2VmdWwgd2hlbiB5b3Ugd2FudCB0byBhbGxvdyBjbGllbnRzIHRvIG1ha2UgYSBidXJzdCBvZlxuICogcmVxdWVzdHMgYW5kIHRoZW4gc3RpbGwgYmUgYWJsZSB0byBtYWtlIHJlcXVlc3RzIGF0IGEgc2xvd2VyIHJhdGUuXG4gKlxuICogQHBhcmFtIHtUb2tlbkJ1Y2tldFJhdGVMaW1pdE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHRva2VuXG4gKiBidWNrZXQgcmF0ZSBsaW1pdGluZyBydWxlLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLm1vZGUgLSBUaGUgYmxvY2sgbW9kZSBvZiB0aGUgcnVsZSwgZWl0aGVyXG4gKiBgXCJMSVZFXCJgIG9yIGBcIkRSWV9SVU5cImAuIGBcIkxJVkVcImAgd2lsbCBibG9jayByZXF1ZXN0cyB3aGVuIHRoZSByYXRlIGxpbWl0IGlzXG4gKiBleGNlZWRlZCwgYW5kIGBcIkRSWV9SVU5cImAgd2lsbCBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nXG4gKiBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy4gRGVmYXVsdHMgdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMucmVmaWxsUmF0ZSAtIFRoZSBudW1iZXIgb2YgdG9rZW5zIHRvIGFkZCB0byB0aGVcbiAqIGJ1Y2tldCBhdCBlYWNoIGludGVydmFsLiBGb3IgZXhhbXBsZSwgaWYgeW91IHNldCB0aGUgaW50ZXJ2YWwgdG8gNjAgYW5kIHRoZVxuICogcmVmaWxsIHJhdGUgdG8gMTAsIHRoZSBidWNrZXQgd2lsbCByZWZpbGwgMTAgdG9rZW5zIGV2ZXJ5IDYwIHNlY29uZHMuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gb3B0aW9ucy5pbnRlcnZhbCAtIFRoZSB0aW1lIGludGVydmFsIGZvciB0aGUgcmVmaWxsXG4gKiByYXRlLiBUaGlzIGNhbiBiZSBhIHN0cmluZyBsaWtlIGBcIjYwc1wiYCBmb3IgNjAgc2Vjb25kcywgYFwiMWg0NW1cImAgZm9yIDEgaG91clxuICogYW5kIDQ1IG1pbnV0ZXMsIG9yIGEgbnVtYmVyIGxpa2UgYDYwYCBmb3IgNjAgc2Vjb25kcy4gVmFsaWQgc3RyaW5nIHRpbWUgdW5pdHNcbiAqIGFyZTpcbiAqIC0gYHNgIGZvciBzZWNvbmRzLlxuICogLSBgbWAgZm9yIG1pbnV0ZXMuXG4gKiAtIGBoYCBmb3IgaG91cnMuXG4gKiAtIGBkYCBmb3IgZGF5cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNhcGFjaXR5IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHRva2VucyB0aGUgYnVja2V0XG4gKiBjYW4gaG9sZC4gVGhlIGJ1Y2tldCBzdGFydHMgYXQgZnVsbCBjYXBhY2l0eSBhbmQgd2lsbCByZWZpbGwgdW50aWwgaXQgaGl0c1xuICogdGhlIGNhcGFjaXR5LlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIHRva2VuIGJ1Y2tldCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGVcbiAqIGBydWxlc2Agb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogdG9rZW5CdWNrZXQoeyBtb2RlOiBcIkxJVkVcIiwgcmVmaWxsUmF0ZTogMTAsIGludGVydmFsOiBcIjYwc1wiLCBjYXBhY2l0eTogMTAwIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIHRva2VuQnVja2V0KHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgcmVmaWxsUmF0ZTogMTAsXG4gKiAgICAgICBpbnRlcnZhbDogXCI2MHNcIixcbiAqICAgICAgIGNhcGFjaXR5OiAxMDAsXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2FsZ29yaXRobXMjdG9rZW4tYnVja2V0XG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiB0b2tlbkJ1Y2tldChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVUb2tlbkJ1Y2tldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiUkFURV9MSU1JVFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IHJlZmlsbFJhdGUgPSBvcHRpb25zLnJlZmlsbFJhdGU7XG4gICAgY29uc3QgaW50ZXJ2YWwgPSBkdXJhdGlvbi5wYXJzZShvcHRpb25zLmludGVydmFsKTtcbiAgICBjb25zdCBjYXBhY2l0eSA9IG9wdGlvbnMuY2FwYWNpdHk7XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlJhdGVMaW1pdCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhbGdvcml0aG06IFwiVE9LRU5fQlVDS0VUXCIsXG4gICAgICAgIHJlZmlsbFJhdGUsXG4gICAgICAgIGludGVydmFsLFxuICAgICAgICBjYXBhY2l0eSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBmaXhlZCB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlLiBBcHBseWluZyB0aGlzIHJ1bGUgc2V0cyBhIGZpeGVkXG4gKiB3aW5kb3cgcmF0ZSBsaW1pdCB3aGljaCB0cmFja3MgdGhlIG51bWJlciBvZiByZXF1ZXN0cyBtYWRlIGJ5IGEgY2xpZW50IG92ZXIgYVxuICogZml4ZWQgdGltZSB3aW5kb3cuXG4gKlxuICogVGhpcyBpcyB0aGUgc2ltcGxlc3QgYWxnb3JpdGhtLiBJdCB0cmFja3MgdGhlIG51bWJlciBvZiByZXF1ZXN0cyBtYWRlIGJ5IGFcbiAqIGNsaWVudCBvdmVyIGEgZml4ZWQgdGltZSB3aW5kb3cgZS5nLiA2MCBzZWNvbmRzLiBJZiB0aGUgY2xpZW50IGV4Y2VlZHMgdGhlXG4gKiBsaW1pdCwgdGhleSBhcmUgYmxvY2tlZCB1bnRpbCB0aGUgd2luZG93IGV4cGlyZXMuXG4gKlxuICogVGhpcyBhbGdvcml0aG0gaXMgdXNlZnVsIHdoZW4geW91IHdhbnQgdG8gYXBwbHkgYSBzaW1wbGUgZml4ZWQgbGltaXQgaW4gYVxuICogZml4ZWQgdGltZSB3aW5kb3cuIEZvciBleGFtcGxlLCBhIHNpbXBsZSBsaW1pdCBvbiB0aGUgdG90YWwgbnVtYmVyIG9mXG4gKiByZXF1ZXN0cyBhIGNsaWVudCBjYW4gbWFrZS4gSG93ZXZlciwgaXQgY2FuIGJlIHN1c2NlcHRpYmxlIHRvIHRoZSBzdGFtcGVkZVxuICogcHJvYmxlbSB3aGVyZSBhIGNsaWVudCBtYWtlcyBhIGJ1cnN0IG9mIHJlcXVlc3RzIGF0IHRoZSBzdGFydCBvZiBhIHdpbmRvdyBhbmRcbiAqIHRoZW4gaXMgYmxvY2tlZCBmb3IgdGhlIHJlc3Qgb2YgdGhlIHdpbmRvdy4gVGhlIHNsaWRpbmcgd2luZG93IGFsZ29yaXRobSBjYW5cbiAqIGJlIHVzZWQgdG8gYXZvaWQgdGhpcy5cbiAqXG4gKiBAcGFyYW0ge0ZpeGVkV2luZG93UmF0ZUxpbWl0T3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgZml4ZWRcbiAqIHdpbmRvdyByYXRlIGxpbWl0aW5nIHJ1bGUuXG4gKiBAcGFyYW0ge0FyY2pldE1vZGV9IG9wdGlvbnMubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLCBlaXRoZXJcbiAqIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIHJlcXVlc3RzIHdoZW4gdGhlIHJhdGUgbGltaXQgaXNcbiAqIGV4Y2VlZGVkLCBhbmQgYFwiRFJZX1JVTlwiYCB3aWxsIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbCBwcm92aWRpbmdcbiAqIGFjY2VzcyB0byB0aGUgcnVsZSByZXN1bHRzLiBEZWZhdWx0cyB0byBgXCJEUllfUlVOXCJgIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gb3B0aW9ucy53aW5kb3cgLSBUaGUgZml4ZWQgdGltZSB3aW5kb3cuIFRoaXMgY2FuIGJlXG4gKiBhIHN0cmluZyBsaWtlIGBcIjYwc1wiYCBmb3IgNjAgc2Vjb25kcywgYFwiMWg0NW1cImAgZm9yIDEgaG91ciBhbmQgNDUgbWludXRlcywgb3JcbiAqIGEgbnVtYmVyIGxpa2UgYDYwYCBmb3IgNjAgc2Vjb25kcy4gVmFsaWQgc3RyaW5nIHRpbWUgdW5pdHMgYXJlOlxuICogLSBgc2AgZm9yIHNlY29uZHMuXG4gKiAtIGBtYCBmb3IgbWludXRlcy5cbiAqIC0gYGhgIGZvciBob3Vycy5cbiAqIC0gYGRgIGZvciBkYXlzLlxuICogQHBhcmFtIHtudW1iZXJ9IG9wdGlvbnMubWF4IC0gVGhlIG1heGltdW0gbnVtYmVyIG9mIHJlcXVlc3RzIGFsbG93ZWQgaW4gdGhlXG4gKiBmaXhlZCB0aW1lIHdpbmRvdy5cbiAqIEByZXR1cm5zIHtQcmltaXRpdmV9IFRoZSBmaXhlZCB3aW5kb3cgcnVsZSB0byBwcm92aWRlIHRvIHRoZSBTREsgaW4gdGhlXG4gKiBgcnVsZXNgIG9wdGlvbi5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGZpeGVkV2luZG93KHsgbW9kZTogXCJMSVZFXCIsIHdpbmRvdzogXCI2MHNcIiwgbWF4OiAxMDAgfSk7XG4gKiBgYGBcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgYWogPSBhcmNqZXQoe1xuICogICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIGZpeGVkV2luZG93KHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgd2luZG93OiBcIjYwc1wiLFxuICogICAgICAgbWF4OiAxMDAsXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2FsZ29yaXRobXMjZml4ZWQtd2luZG93XG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBmaXhlZFdpbmRvdyhvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVGaXhlZFdpbmRvd09wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiUkFURV9MSU1JVFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4O1xuICAgIGNvbnN0IHdpbmRvdyA9IGR1cmF0aW9uLnBhcnNlKG9wdGlvbnMud2luZG93KTtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuUmF0ZUxpbWl0LFxuICAgICAgICBtb2RlLFxuICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgIGFsZ29yaXRobTogXCJGSVhFRF9XSU5ET1dcIixcbiAgICAgICAgbWF4LFxuICAgICAgICB3aW5kb3csXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBBcmNqZXQgc2xpZGluZyB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlLiBBcHBseWluZyB0aGlzIHJ1bGUgc2V0cyBhIHNsaWRpbmdcbiAqIHdpbmRvdyByYXRlIGxpbWl0IHdoaWNoIHRyYWNrcyB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzIG1hZGUgYnkgYSBjbGllbnQgb3ZlciBhXG4gKiBzbGlkaW5nIHdpbmRvdyBzbyB0aGF0IHRoZSB3aW5kb3cgbW92ZXMgd2l0aCB0aW1lLlxuICpcbiAqIFRoaXMgYWxnb3JpdGhtIGlzIHVzZWZ1bCB0byBhdm9pZCB0aGUgc3RhbXBlZGUgcHJvYmxlbSBvZiB0aGUgZml4ZWQgd2luZG93LlxuICogSXQgcHJvdmlkZXMgc21vb3RoZXIgcmF0ZSBsaW1pdGluZyBvdmVyIHRpbWUgYW5kIGNhbiBwcmV2ZW50IGEgY2xpZW50IGZyb21cbiAqIG1ha2luZyBhIGJ1cnN0IG9mIHJlcXVlc3RzIGF0IHRoZSBzdGFydCBvZiBhIHdpbmRvdyBhbmQgdGhlbiBiZWluZyBibG9ja2VkXG4gKiBmb3IgdGhlIHJlc3Qgb2YgdGhlIHdpbmRvdy5cbiAqXG4gKiBAcGFyYW0ge1NsaWRpbmdXaW5kb3dSYXRlTGltaXRPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBzbGlkaW5nXG4gKiB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLm1vZGUgLSBUaGUgYmxvY2sgbW9kZSBvZiB0aGUgcnVsZSwgZWl0aGVyXG4gKiBgXCJMSVZFXCJgIG9yIGBcIkRSWV9SVU5cImAuIGBcIkxJVkVcImAgd2lsbCBibG9jayByZXF1ZXN0cyB3aGVuIHRoZSByYXRlIGxpbWl0IGlzXG4gKiBleGNlZWRlZCwgYW5kIGBcIkRSWV9SVU5cImAgd2lsbCBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nXG4gKiBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy4gRGVmYXVsdHMgdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IG9wdGlvbnMuaW50ZXJ2YWwgLSBUaGUgdGltZSBpbnRlcnZhbCBmb3IgdGhlIHJhdGVcbiAqIGxpbWl0LiBUaGlzIGNhbiBiZSBhIHN0cmluZyBsaWtlIGBcIjYwc1wiYCBmb3IgNjAgc2Vjb25kcywgYFwiMWg0NW1cImAgZm9yIDEgaG91clxuICogYW5kIDQ1IG1pbnV0ZXMsIG9yIGEgbnVtYmVyIGxpa2UgYDYwYCBmb3IgNjAgc2Vjb25kcy4gVmFsaWQgc3RyaW5nIHRpbWUgdW5pdHNcbiAqIGFyZTpcbiAqIC0gYHNgIGZvciBzZWNvbmRzLlxuICogLSBgbWAgZm9yIG1pbnV0ZXMuXG4gKiAtIGBoYCBmb3IgaG91cnMuXG4gKiAtIGBkYCBmb3IgZGF5cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLm1heCAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZXF1ZXN0cyBhbGxvd2VkIGluIHRoZVxuICogc2xpZGluZyB0aW1lIHdpbmRvdy5cbiAqIEByZXR1cm5zIHtQcmltaXRpdmV9IFRoZSBzbGlkaW5nIHdpbmRvdyBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGVcbiAqIGBydWxlc2Agb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogc2xpZGluZ1dpbmRvdyh7IG1vZGU6IFwiTElWRVwiLCBpbnRlcnZhbDogXCI2MHNcIiwgbWF4OiAxMDAgfSk7XG4gKiBgYGBcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogY29uc3QgYWogPSBhcmNqZXQoe1xuICogICBrZXk6IHByb2Nlc3MuZW52LkFSQ0pFVF9LRVksXG4gKiAgIHJ1bGVzOiBbXG4gKiAgICAgc2xpZGluZ1dpbmRvdyh7XG4gKiAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgIGludGVydmFsOiBcIjYwc1wiLFxuICogICAgICAgbWF4OiAxMDAsXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9yYXRlLWxpbWl0aW5nL2FsZ29yaXRobXMjc2xpZGluZy13aW5kb3dcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3JhdGUtbGltaXRpbmcvcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHNsaWRpbmdXaW5kb3cob3B0aW9ucykge1xuICAgIHZhbGlkYXRlU2xpZGluZ1dpbmRvd09wdGlvbnMob3B0aW9ucyk7XG4gICAgY29uc3QgdHlwZSA9IFwiUkFURV9MSU1JVFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBBcnJheS5pc0FycmF5KG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzKVxuICAgICAgICA/IG9wdGlvbnMuY2hhcmFjdGVyaXN0aWNzXG4gICAgICAgIDogdW5kZWZpbmVkO1xuICAgIGNvbnN0IG1heCA9IG9wdGlvbnMubWF4O1xuICAgIGNvbnN0IGludGVydmFsID0gZHVyYXRpb24ucGFyc2Uob3B0aW9ucy5pbnRlcnZhbCk7XG4gICAgY29uc3QgcnVsZSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgdmVyc2lvbixcbiAgICAgICAgcHJpb3JpdHk6IFByaW9yaXR5LlJhdGVMaW1pdCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgY2hhcmFjdGVyaXN0aWNzLFxuICAgICAgICBhbGdvcml0aG06IFwiU0xJRElOR19XSU5ET1dcIixcbiAgICAgICAgbWF4LFxuICAgICAgICBpbnRlcnZhbCxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG5mdW5jdGlvbiBwcm90b2NvbFNlbnNpdGl2ZUluZm9FbnRpdGllc1RvQW5hbHl6ZShlbnRpdHkpIHtcbiAgICBpZiAodHlwZW9mIGVudGl0eSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGVudGl0eSB0eXBlXCIpO1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIkVNQUlMXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImVtYWlsXCIgfTtcbiAgICB9XG4gICAgaWYgKGVudGl0eSA9PT0gXCJQSE9ORV9OVU1CRVJcIikge1xuICAgICAgICByZXR1cm4geyB0YWc6IFwicGhvbmUtbnVtYmVyXCIgfTtcbiAgICB9XG4gICAgaWYgKGVudGl0eSA9PT0gXCJJUF9BRERSRVNTXCIpIHtcbiAgICAgICAgcmV0dXJuIHsgdGFnOiBcImlwLWFkZHJlc3NcIiB9O1xuICAgIH1cbiAgICBpZiAoZW50aXR5ID09PSBcIkNSRURJVF9DQVJEX05VTUJFUlwiKSB7XG4gICAgICAgIHJldHVybiB7IHRhZzogXCJjcmVkaXQtY2FyZC1udW1iZXJcIiB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICB0YWc6IFwiY3VzdG9tXCIsXG4gICAgICAgIHZhbDogZW50aXR5LFxuICAgIH07XG59XG5mdW5jdGlvbiBhbmFseXplU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9TdHJpbmcoZW50aXR5KSB7XG4gICAgaWYgKGVudGl0eS50YWcgPT09IFwiZW1haWxcIikge1xuICAgICAgICByZXR1cm4gXCJFTUFJTFwiO1xuICAgIH1cbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJpcC1hZGRyZXNzXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiSVBfQUREUkVTU1wiO1xuICAgIH1cbiAgICBpZiAoZW50aXR5LnRhZyA9PT0gXCJjcmVkaXQtY2FyZC1udW1iZXJcIikge1xuICAgICAgICByZXR1cm4gXCJDUkVESVRfQ0FSRF9OVU1CRVJcIjtcbiAgICB9XG4gICAgaWYgKGVudGl0eS50YWcgPT09IFwicGhvbmUtbnVtYmVyXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiUEhPTkVfTlVNQkVSXCI7XG4gICAgfVxuICAgIHJldHVybiBlbnRpdHkudmFsO1xufVxuZnVuY3Rpb24gY29udmVydEFuYWx5emVEZXRlY3RlZFNlbnNpdGl2ZUluZm9FbnRpdHkoZGV0ZWN0ZWRFbnRpdGllcykge1xuICAgIHJldHVybiBkZXRlY3RlZEVudGl0aWVzLm1hcCgoZGV0ZWN0ZWRFbnRpdHkpID0+IHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLmRldGVjdGVkRW50aXR5LFxuICAgICAgICAgICAgaWRlbnRpZmllZFR5cGU6IGFuYWx5emVTZW5zaXRpdmVJbmZvRW50aXRpZXNUb1N0cmluZyhkZXRlY3RlZEVudGl0eS5pZGVudGlmaWVkVHlwZSksXG4gICAgICAgIH07XG4gICAgfSk7XG59XG4vKipcbiAqIEFyY2pldCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gZGV0ZWN0aW9uIHJ1bGUuIEFwcGx5aW5nIHRoaXMgcnVsZSBwcm90ZWN0c1xuICogYWdhaW5zdCBjbGllbnRzIHNlbmRpbmcgeW91IHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBzdWNoIGFzIHBlcnNvbmFsbHlcbiAqIGlkZW50aWZpYWJsZSBpbmZvcm1hdGlvbiAoUElJKSB0aGF0IHlvdSBkbyBub3Qgd2lzaCB0byBoYW5kbGUuIFRoZSBydWxlIHJ1bnNcbiAqIGVudGlyZWx5IGxvY2FsbHkgc28gbm8gZGF0YSBldmVyIGxlYXZlcyB5b3VyIGVudmlyb25tZW50LlxuICpcbiAqIFRoaXMgcnVsZSBpbmNsdWRlcyBidWlsdC1pbiBkZXRlY3Rpb25zIGZvciBlbWFpbCBhZGRyZXNzZXMsIGNyZWRpdC9kZWJpdCBjYXJkXG4gKiBudW1iZXJzLCBJUCBhZGRyZXNzZXMsIGFuZCBwaG9uZSBudW1iZXJzLiBZb3UgY2FuIGFsc28gcHJvdmlkZSBhIGN1c3RvbVxuICogZGV0ZWN0aW9uIGZ1bmN0aW9uIHRvIGlkZW50aWZ5IGFkZGl0aW9uYWwgc2Vuc2l0aXZlIGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSB7U2Vuc2l0aXZlSW5mb09wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIHNlbnNpdGl2ZVxuICogaW5mb3JtYXRpb24gZGV0ZWN0aW9uIHJ1bGUuXG4gKiBAcGFyYW0ge0FyY2pldE1vZGV9IG9wdGlvbnMubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLCBlaXRoZXJcbiAqIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIHJlcXVlc3RzIHdoZW4gYW55IG9mIHRoZVxuICogY29uZmlndXJlZCBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdHlwZXMgYXJlIGRldGVjdGVkLCBhbmQgYFwiRFJZX1JVTlwiYCB3aWxsXG4gKiBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nIGFjY2VzcyB0byB0aGUgcnVsZSByZXN1bHRzLiBEZWZhdWx0c1xuICogdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRTZW5zaXRpdmVJbmZvVHlwZT59IG9wdGlvbnMuZGVueSAtIFRoZSBsaXN0IG9mIHNlbnNpdGl2ZVxuICogaW5mb3JtYXRpb24gdHlwZXMgdG8gZGVueS4gSWYgcHJvdmlkZWQsIHRoZSBzZW5zaXRpdmUgaW5mb3JtYXRpb24gdHlwZXMgaW5cbiAqIHRoaXMgbGlzdCB3aWxsIGJlIGRlbmllZC4gWW91IG1heSBvbmx5IHByb3ZpZGUgZWl0aGVyIGBhbGxvd2Agb3IgYGRlbnlgLCBub3RcbiAqIGJvdGguIFNwZWNpZnkgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiAtIGBcIkVNQUlMXCJgXG4gKiAtIGBcIlBIT05FX05VTUJFUlwiYFxuICogLSBgXCJJUF9BRERSRVNTXCJgXG4gKiAtIGBcIkNSRURJVF9DQVJEX05VTUJFUlwiYFxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRTZW5zaXRpdmVJbmZvVHlwZT59IG9wdGlvbnMuYWxsb3cgLSBUaGUgbGlzdCBvZiBzZW5zaXRpdmVcbiAqIGluZm9ybWF0aW9uIHR5cGVzIHRvIGFsbG93LiBJZiBwcm92aWRlZCwgdHlwZXMgaW4gdGhpcyBsaXN0IHdpbGwgYmUgYWxsb3dlZFxuICogYW5kIGFsbCBvdGhlcnMgd2lsbCBiZSBkZW5pZWQuIFlvdSBtYXkgb25seSBwcm92aWRlIGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCxcbiAqIG5vdCBib3RoLiBUaGUgc2FtZSBvcHRpb25zIGFwcGx5IGFzIGZvciBgZGVueWAuXG4gKiBAcGFyYW0ge0RldGVjdFNlbnNpdGl2ZUluZm9FbnRpdGllc30gb3B0aW9ucy5kZXRlY3QgLSBBIGN1c3RvbSBkZXRlY3Rpb25cbiAqIGZ1bmN0aW9uLiBUaGUgZnVuY3Rpb24gd2lsbCB0YWtlIGEgbGlzdCBvZiB0b2tlbnMgYW5kIG11c3QgcmV0dXJuIGEgbGlzdCBvZlxuICogZWl0aGVyIGB1bmRlZmluZWRgLCBpZiB0aGUgY29ycmVzcG9uZGluZyB0b2tlbiBpbiB0aGUgaW5wdXQgbGlzdCBpcyBub3RcbiAqIHNlbnNpdGl2ZSwgb3IgdGhlIG5hbWUgb2YgdGhlIGVudGl0eSBpZiBpdCBkb2VzIG1hdGNoLiBUaGUgbnVtYmVyIG9mIHRva2Vuc1xuICogdGhhdCBhcmUgcHJvdmlkZWQgdG8gdGhlIGZ1bmN0aW9uIGlzIGNvbnRyb2xsZWQgYnkgdGhlIGBjb250ZXh0V2luZG93U2l6ZWBcbiAqIG9wdGlvbiwgd2hpY2ggZGVmYXVsdHMgdG8gYDFgLiBJZiB5b3UgbmVlZCBhZGRpdGlvbmFsIGNvbnRleHQgdG8gcGVyZm9ybVxuICogZGV0ZWN0aW9ucyB0aGVuIHlvdSBjYW4gaW5jcmVhc2UgdGhpcyB2YWx1ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLmNvbnRleHRXaW5kb3dTaXplIC0gVGhlIG51bWJlciBvZiB0b2tlbnMgdG8gcHJvdmlkZVxuICogdG8gdGhlIGN1c3RvbSBkZXRlY3Rpb24gZnVuY3Rpb24uIFRoaXMgZGVmYXVsdHMgdG8gMSBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIHNlbnNpdGl2ZSBpbmZvcm1hdGlvbiBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpblxuICogdGhlIGBydWxlc2Agb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogc2Vuc2l0aXZlSW5mbyh7IG1vZGU6IFwiTElWRVwiLCBkZW55OiBbXCJFTUFJTFwiXSB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtcbiAqICAgICBzZW5zaXRpdmVJbmZvKHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgZGVueTogW1wiRU1BSUxcIl0sXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogQ3VzdG9tIGRldGVjdGlvbiBmdW5jdGlvbjpcbiAqIGBgYHRzXG4gKiBmdW5jdGlvbiBkZXRlY3REYXNoKHRva2Vuczogc3RyaW5nW10pOiBBcnJheTxcIkNPTlRBSU5TX0RBU0hcIiB8IHVuZGVmaW5lZD4ge1xuICogICByZXR1cm4gdG9rZW5zLm1hcCgodG9rZW4pID0+IHtcbiAqICAgICBpZiAodG9rZW4uaW5jbHVkZXMoXCItXCIpKSB7XG4gKiAgICAgICByZXR1cm4gXCJDT05UQUlOU19EQVNIXCI7XG4gKiAgICAgfVxuICogICB9KTtcbiAqIH1cbiAqXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtcbiAqICAgICBzZW5zaXRpdmVJbmZvKHtcbiAqICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgZGVueTogW1wiRU1BSUxcIiwgXCJDT05UQUlOU19EQVNIXCJdLFxuICogICAgICAgZGV0ZWN0OiBkZXRlY3REYXNoLFxuICogICAgICAgY29udGV4dFdpbmRvd1NpemU6IDIsXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zZW5zaXRpdmUtaW5mby9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vc2Vuc2l0aXZlLWluZm8vcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHNlbnNpdGl2ZUluZm8ob3B0aW9ucykge1xuICAgIHZhbGlkYXRlU2Vuc2l0aXZlSW5mb09wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHNlbnNpdGl2ZUluZm9gIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBkZW55YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBzZW5zaXRpdmVJbmZvYCBvcHRpb25zIGVycm9yOiBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAgbXVzdCBiZSBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBcIlNFTlNJVElWRV9JTkZPXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy5hbGxvdyB8fCBbXTtcbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy5kZW55IHx8IFtdO1xuICAgIGNvbnN0IGlkID0gaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgZGVueSkpO1xuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5TZW5zaXRpdmVJbmZvLFxuICAgICAgICB0eXBlLFxuICAgICAgICBtb2RlLFxuICAgICAgICBhbGxvdyxcbiAgICAgICAgZGVueSxcbiAgICAgICAgdmFsaWRhdGUoY29udGV4dCwgZGV0YWlscykgeyB9LFxuICAgICAgICBhc3luYyBwcm90ZWN0KGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGlkO1xuICAgICAgICAgICAgY29uc3QgYm9keSA9IGF3YWl0IGNvbnRleHQuZ2V0Qm9keSgpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBib2R5ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlOiBcIk5PVF9SVU5cIixcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFcnJvclJlYXNvbihcIkNvdWxkbid0IHJlYWQgdGhlIGJvZHkgb2YgdGhlIHJlcXVlc3QgdG8gcGVyZm9ybSBzZW5zaXRpdmUgaW5mbyBpZGVudGlmaWNhdGlvbi5cIiksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgY29udmVydGVkRGV0ZWN0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRldGVjdCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRldGVjdCA9IG9wdGlvbnMuZGV0ZWN0O1xuICAgICAgICAgICAgICAgIGNvbnZlcnRlZERldGVjdCA9ICh0b2tlbnMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRldGVjdCh0b2tlbnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAuZmlsdGVyKChlKSA9PiB0eXBlb2YgZSAhPT0gXCJ1bmRlZmluZWRcIilcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAocHJvdG9jb2xTZW5zaXRpdmVJbmZvRW50aXRpZXNUb0FuYWx5emUpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgZW50aXRpZXNUYWcgPSBcImFsbG93XCI7XG4gICAgICAgICAgICBsZXQgZW50aXRpZXNWYWwgPSBbXTtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuYWxsb3cpKSB7XG4gICAgICAgICAgICAgICAgZW50aXRpZXNUYWcgPSBcImFsbG93XCI7XG4gICAgICAgICAgICAgICAgZW50aXRpZXNWYWwgPSBvcHRpb25zLmFsbG93XG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IHR5cGVvZiBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHByb3RvY29sU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9BbmFseXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KG9wdGlvbnMuZGVueSkpIHtcbiAgICAgICAgICAgICAgICBlbnRpdGllc1RhZyA9IFwiZGVueVwiO1xuICAgICAgICAgICAgICAgIGVudGl0aWVzVmFsID0gb3B0aW9ucy5kZW55XG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKGUpID0+IHR5cGVvZiBlICE9PSBcInVuZGVmaW5lZFwiKVxuICAgICAgICAgICAgICAgICAgICAubWFwKHByb3RvY29sU2Vuc2l0aXZlSW5mb0VudGl0aWVzVG9BbmFseXplKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVudGl0aWVzID0ge1xuICAgICAgICAgICAgICAgIHRhZzogZW50aXRpZXNUYWcsXG4gICAgICAgICAgICAgICAgdmFsOiBlbnRpdGllc1ZhbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplLmRldGVjdFNlbnNpdGl2ZUluZm8oY29udGV4dCwgYm9keSwgZW50aXRpZXMsIG9wdGlvbnMuY29udGV4dFdpbmRvd1NpemUgfHwgMSwgY29udmVydGVkRGV0ZWN0KTtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gbW9kZSA9PT0gXCJMSVZFXCIgPyBcIlJVTlwiIDogXCJEUllfUlVOXCI7XG4gICAgICAgICAgICBjb25zdCByZWFzb24gPSBuZXcgQXJjamV0U2Vuc2l0aXZlSW5mb1JlYXNvbih7XG4gICAgICAgICAgICAgICAgZGVuaWVkOiBjb252ZXJ0QW5hbHl6ZURldGVjdGVkU2Vuc2l0aXZlSW5mb0VudGl0eShyZXN1bHQuZGVuaWVkKSxcbiAgICAgICAgICAgICAgICBhbGxvd2VkOiBjb252ZXJ0QW5hbHl6ZURldGVjdGVkU2Vuc2l0aXZlSW5mb0VudGl0eShyZXN1bHQuYWxsb3dlZCksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQuZGVuaWVkLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJBTExPV1wiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiREVOWVwiLFxuICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBBcmNqZXQgZW1haWwgdmFsaWRhdGlvbiBydWxlLiBBcHBseWluZyB0aGlzIHJ1bGUgYWxsb3dzIHlvdSB0byB2YWxpZGF0ZSAmXG4gKiB2ZXJpZnkgYW4gZW1haWwgYWRkcmVzcy5cbiAqXG4gKiBUaGUgZmlyc3Qgc3RlcCBvZiB0aGUgYW5hbHlzaXMgaXMgdG8gdmFsaWRhdGUgdGhlIGVtYWlsIGFkZHJlc3Mgc3ludGF4LiBUaGlzXG4gKiBydW5zIGxvY2FsbHkgd2l0aGluIHRoZSBTREsgYW5kIHZhbGlkYXRlcyB0aGUgZW1haWwgYWRkcmVzcyBpcyBpbiB0aGUgY29ycmVjdFxuICogZm9ybWF0LiBJZiB0aGUgZW1haWwgc3ludGF4IGlzIHZhbGlkLCB0aGUgU0RLIHdpbGwgcGFzcyB0aGUgZW1haWwgYWRkcmVzcyB0b1xuICogdGhlIEFyY2pldCBjbG91ZCBBUEkgdG8gdmVyaWZ5IHRoZSBlbWFpbCBhZGRyZXNzLiBUaGlzIHBlcmZvcm1zIHNldmVyYWxcbiAqIGNoZWNrcywgZGVwZW5kaW5nIG9uIHRoZSBydWxlIGNvbmZpZ3VyYXRpb24uXG4gKlxuICogQHBhcmFtIHtFbWFpbE9wdGlvbnN9IG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBmb3IgdGhlIGVtYWlsIHZhbGlkYXRpb24gcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgZW1haWwgYWRkcmVzc2VzIGJhc2VkIG9uIHRoZVxuICogY29uZmlndXJhdGlvbiwgYW5kIGBcIkRSWV9SVU5cImAgd2lsbCBhbGxvdyBhbGwgcmVxdWVzdHMgd2hpbGUgc3RpbGwgcHJvdmlkaW5nXG4gKiBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy4gRGVmYXVsdHMgdG8gYFwiRFJZX1JVTlwiYCBpZiBub3Qgc3BlY2lmaWVkLlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRFbWFpbFR5cGU+fSBvcHRpb25zLmRlbnkgLSBUaGUgbGlzdCBvZiBlbWFpbCB0eXBlcyB0b1xuICogZGVueS4gSWYgcHJvdmlkZWQsIHRoZSBlbWFpbCB0eXBlcyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSBkZW5pZWQuIFlvdSBtYXkgb25seVxuICogcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdCBib3RoLiBTcGVjaWZ5IG9uZSBvciBtb3JlIG9mIHRoZVxuICogZm9sbG93aW5nOlxuICpcbiAqIC0gYFwiRElTUE9TQUJMRVwiYCAtIERpc3Bvc2FibGUgZW1haWwgYWRkcmVzc2VzLlxuICogLSBgXCJGUkVFXCJgIC0gRnJlZSBlbWFpbCBhZGRyZXNzZXMuXG4gKiAtIGBcIk5PX01YX1JFQ09SRFNcImAgLSBFbWFpbCBhZGRyZXNzZXMgd2l0aCBubyBNWCByZWNvcmRzLlxuICogLSBgXCJOT19HUkFWQVRBUlwiYCAtIEVtYWlsIGFkZHJlc3NlcyB3aXRoIG5vIEdyYXZhdGFyLlxuICogLSBgXCJJTlZBTElEXCJgIC0gSW52YWxpZCBlbWFpbCBhZGRyZXNzZXMuXG4gKlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRFbWFpbFR5cGU+fSBvcHRpb25zLmFsbG93IC0gVGhlIGxpc3Qgb2YgZW1haWwgdHlwZXMgdG9cbiAqIGFsbG93LiBJZiBwcm92aWRlZCwgZW1haWwgYWRkcmVzc2VzIGluIHRoaXMgbGlzdCB3aWxsIGJlIGFsbG93ZWQgYW5kIGFsbFxuICogb3RoZXJzIHdpbGwgYmUgZGVuaWVkLiBZb3UgbWF5IG9ubHkgcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdFxuICogYm90aC4gVGhlIHNhbWUgb3B0aW9ucyBhcHBseSBhcyBmb3IgYGRlbnlgLlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIGVtYWlsIHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgXG4gKiBvcHRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiB2YWxpZGF0ZUVtYWlsKHsgbW9kZTogXCJMSVZFXCIsIGRlbnk6IFtcIkRJU1BPU0FCTEVcIiwgXCJJTlZBTElEXCJdIH0pO1xuICogYGBgXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIHZhbGlkYXRlRW1haWwoe1xuICogICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICBkZW55OiBbXCJESVNQT1NBQkxFXCIsIFwiSU5WQUxJRFwiXVxuICogICAgIH0pXG4gKiAgIF0sXG4gKiB9KTtcbiAqIGBgYFxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vZW1haWwtdmFsaWRhdGlvbi9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vZW1haWwtdmFsaWRhdGlvbi9yZWZlcmVuY2VcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVFbWFpbChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVFbWFpbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHZhbGlkYXRlRW1haWxgIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBkZW55YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5ibG9jayAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgdmFsaWRhdGVFbWFpbGAgb3B0aW9ucyBlcnJvcjogYGFsbG93YCBhbmQgYGJsb2NrYCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmJsb2NrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImB2YWxpZGF0ZUVtYWlsYCBvcHRpb25zIGVycm9yOiBgZGVueWAgYW5kIGBibG9ja2AgY2Fubm90IGJlIHByb3ZpZGVkIHRvZ2V0aGVyLCBgYmxvY2tgIGlzIG5vdyBkZXByZWNhdGVkIHNvIGBkZW55YCBzaG91bGQgYmUgcHJlZmVycmVkLlwiKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ID09PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBvcHRpb25zLmRlbnkgPT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdHlwZW9mIG9wdGlvbnMuYmxvY2sgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYHZhbGlkYXRlRW1haWxgIG9wdGlvbnMgZXJyb3I6IGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFwiRU1BSUxcIjtcbiAgICBjb25zdCB2ZXJzaW9uID0gMDtcbiAgICBjb25zdCBtb2RlID0gb3B0aW9ucy5tb2RlID09PSBcIkxJVkVcIiA/IFwiTElWRVwiIDogXCJEUllfUlVOXCI7XG4gICAgY29uc3QgYWxsb3cgPSBvcHRpb25zLmFsbG93ID8/IFtdO1xuICAgIGNvbnN0IGRlbnkgPSBvcHRpb25zLmRlbnkgPz8gb3B0aW9ucy5ibG9jayA/PyBbXTtcbiAgICBjb25zdCByZXF1aXJlVG9wTGV2ZWxEb21haW4gPSBvcHRpb25zLnJlcXVpcmVUb3BMZXZlbERvbWFpbiA/PyB0cnVlO1xuICAgIGNvbnN0IGFsbG93RG9tYWluTGl0ZXJhbCA9IG9wdGlvbnMuYWxsb3dEb21haW5MaXRlcmFsID8/IGZhbHNlO1xuICAgIGNvbnN0IGlkID0gaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgZGVueSksIGhhc2hlci5ib29sKFwicmVxdWlyZVRvcExldmVsRG9tYWluXCIsIHJlcXVpcmVUb3BMZXZlbERvbWFpbiksIGhhc2hlci5ib29sKFwiYWxsb3dEb21haW5MaXRlcmFsXCIsIGFsbG93RG9tYWluTGl0ZXJhbCkpO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIHRhZzogXCJkZW55LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgIHZhbDoge1xuICAgICAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgZGVueTogW10sXG4gICAgICAgIH0sXG4gICAgfTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuYWxsb3cgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgdGFnOiBcImFsbG93LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIGFsbG93OiBvcHRpb25zLmFsbG93LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlbnkgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY29uZmlnID0ge1xuICAgICAgICAgICAgdGFnOiBcImRlbnktZW1haWwtdmFsaWRhdGlvbi1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIHJlcXVpcmVUb3BMZXZlbERvbWFpbixcbiAgICAgICAgICAgICAgICBhbGxvd0RvbWFpbkxpdGVyYWwsXG4gICAgICAgICAgICAgICAgZGVueTogb3B0aW9ucy5kZW55LFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmJsb2NrICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJkZW55LWVtYWlsLXZhbGlkYXRpb24tY29uZmlnXCIsXG4gICAgICAgICAgICB2YWw6IHtcbiAgICAgICAgICAgICAgICByZXF1aXJlVG9wTGV2ZWxEb21haW4sXG4gICAgICAgICAgICAgICAgYWxsb3dEb21haW5MaXRlcmFsLFxuICAgICAgICAgICAgICAgIGRlbnk6IG9wdGlvbnMuYmxvY2ssXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuRW1haWxWYWxpZGF0aW9uLFxuICAgICAgICB0eXBlLFxuICAgICAgICBtb2RlLFxuICAgICAgICBhbGxvdyxcbiAgICAgICAgZGVueSxcbiAgICAgICAgcmVxdWlyZVRvcExldmVsRG9tYWluLFxuICAgICAgICBhbGxvd0RvbWFpbkxpdGVyYWwsXG4gICAgICAgIHZhbGlkYXRlKGNvbnRleHQsIGRldGFpbHMpIHtcbiAgICAgICAgICAgIGFzc2VydCh0eXBlb2YgZGV0YWlscy5lbWFpbCAhPT0gXCJ1bmRlZmluZWRcIiwgXCJWYWxpZGF0ZUVtYWlsIHJlcXVpcmVzIGBlbWFpbGAgdG8gYmUgc2V0LlwiKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjb250ZXh0LCB7IGVtYWlsIH0pIHtcbiAgICAgICAgICAgIGNvbnN0IHJ1bGVJZCA9IGF3YWl0IGlkO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgYW5hbHl6ZS5pc1ZhbGlkRW1haWwoY29udGV4dCwgZW1haWwsIGNvbmZpZyk7XG4gICAgICAgICAgICBjb25zdCBzdGF0ZSA9IG1vZGUgPT09IFwiTElWRVwiID8gXCJSVU5cIiA6IFwiRFJZX1JVTlwiO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52YWxpZGl0eSA9PT0gXCJ2YWxpZFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLFxuICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiBcIkFMTE9XXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVtYWlsUmVhc29uKHsgZW1haWxUeXBlczogW10gfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlZEVtYWlsVHlwZXMgPSByZXN1bHQuYmxvY2tlZC5maWx0ZXIoaXNFbWFpbFR5cGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJERU5ZXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVtYWlsUmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVtYWlsVHlwZXM6IHR5cGVkRW1haWxUeXBlcyxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgfTtcbiAgICByZXR1cm4gW3J1bGVdO1xufVxuLyoqXG4gKiBBcmNqZXQgYm90IGRldGVjdGlvbiBydWxlLiBBcHBseWluZyB0aGlzIHJ1bGUgYWxsb3dzIHlvdSB0byBtYW5hZ2UgdHJhZmZpYyBieVxuICogYXV0b21hdGVkIGNsaWVudHMgYW5kIGJvdHMuXG4gKlxuICogQm90cyBjYW4gYmUgZ29vZCAoc3VjaCBhcyBzZWFyY2ggZW5naW5lIGNyYXdsZXJzIG9yIG1vbml0b3JpbmcgYWdlbnRzKSBvciBiYWRcbiAqIChzdWNoIGFzIHNjcmFwZXJzIG9yIGF1dG9tYXRlZCBzY3JpcHRzKS4gQXJjamV0IGFsbG93cyB5b3UgdG8gY29uZmlndXJlIHdoaWNoXG4gKiBib3RzIHlvdSB3YW50IHRvIGFsbG93IG9yIGRlbnkgYnkgc3BlY2lmaWMgYm90IG5hbWVzIGUuZy4gY3VybCwgYXMgd2VsbCBhcyBieVxuICogY2F0ZWdvcnkgZS5nLiBzZWFyY2ggZW5naW5lIGJvdHMuXG4gKlxuICogQm90cyBhcmUgZGV0ZWN0ZWQgYmFzZWQgb24gdmFyaW91cyBzaWduYWxzIHN1Y2ggYXMgdGhlIHVzZXIgYWdlbnQsIElQXG4gKiBhZGRyZXNzLCBETlMgcmVjb3JkcywgYW5kIG1vcmUuXG4gKlxuICogQHBhcmFtIHtCb3RPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBib3QgcnVsZS5cbiAqIEBwYXJhbSB7QXJjamV0TW9kZX0gb3B0aW9ucy5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgZGV0ZWN0ZWQgYm90cywgYW5kIGBcIkRSWV9SVU5cImBcbiAqIHdpbGwgYWxsb3cgYWxsIHJlcXVlc3RzIHdoaWxlIHN0aWxsIHByb3ZpZGluZyBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy5cbiAqIERlZmF1bHRzIHRvIGBcIkRSWV9SVU5cImAgaWYgbm90IHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJjamV0V2VsbEtub3duQm90IHwgQXJjamV0Qm90Q2F0ZWdvcnk+fSBvcHRpb25zLmFsbG93IC0gVGhlXG4gKiBsaXN0IG9mIGJvdHMgdG8gYWxsb3cuIElmIHByb3ZpZGVkLCBvbmx5IHRoZSBib3RzIGluIHRoaXMgbGlzdCB3aWxsIGJlXG4gKiBhbGxvd2VkIGFuZCBhbnkgb3RoZXIgZGV0ZWN0ZWQgYm90IHdpbGwgYmUgZGVuaWVkLiBJZiBlbXB0eSwgYWxsIGJvdHMgd2lsbCBiZVxuICogZGVuaWVkLiBZb3UgbWF5IG9ubHkgcHJvdmlkZSBlaXRoZXIgYGFsbG93YCBvciBgZGVueWAsIG5vdCBib3RoLiBZb3UgY2FuIHVzZVxuICogc3BlY2lmaWMgYm90cyBlLmcuIGBcIkNVUkxcImAgd2lsbCBhbGxvdyB0aGUgZGVmYXVsdCB1c2VyLWFnZW50IG9mIHRoZSBgY3VybGBcbiAqIHRvb2wuIFlvdSBjYW4gYWxzbyB1c2UgY2F0ZWdvcmllcyBlLmcuIGBcIkNBVEVHT1JZOlNFQVJDSF9FTkdJTkVcImAgd2lsbCBhbGxvd1xuICogYWxsIHNlYXJjaCBlbmdpbmUgYm90cy4gU2VlXG4gKiBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9pZGVudGlmeWluZy1ib3RzIGZvciB0aGUgZnVsbCBsaXN0IG9mXG4gKiBib3RzIGFuZCBjYXRlZ29yaWVzLlxuICogQHBhcmFtIHtBcnJheTxBcmNqZXRXZWxsS25vd25Cb3QgfCBBcmNqZXRCb3RDYXRlZ29yeT59IG9wdGlvbnMuZGVueSAtIFRoZVxuICogbGlzdCBvZiBib3RzIHRvIGRlbnkuIElmIHByb3ZpZGVkLCB0aGUgYm90cyBpbiB0aGlzIGxpc3Qgd2lsbCBiZSBkZW5pZWQgYW5kXG4gKiBhbGwgb3RoZXIgZGV0ZWN0ZWQgYm90cyB3aWxsIGJlIGFsbG93ZWQuIFlvdSBtYXkgb25seSBwcm92aWRlIGVpdGhlciBgYWxsb3dgXG4gKiBvciBgZGVueWAsIG5vdCBib3RoLiBUaGUgc2FtZSBvcHRpb25zIGFwcGx5IGFzIGZvciBgYWxsb3dgLlxuICogQHJldHVybnMge1ByaW1pdGl2ZX0gVGhlIGJvdCBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpbiB0aGUgYHJ1bGVzYFxuICogb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBBbGxvd3Mgc2VhcmNoIGVuZ2luZSBib3RzIGFuZCBjdXJsLCBkZW5pZXMgYWxsIG90aGVyIGJvdHNcbiAqXG4gKiBgYGB0c1xuICogZGV0ZWN0Qm90KHsgbW9kZTogXCJMSVZFXCIsIGFsbG93OiBbXCJDQVRFR09SWTpTRUFSQ0hfRU5HSU5FXCIsIFwiQ1VSTFwiXSB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIEFsbG93cyBzZWFyY2ggZW5naW5lIGJvdHMgYW5kIGN1cmwsIGRlbmllcyBhbGwgb3RoZXIgYm90c1xuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtcbiAqICAgICBkZXRlY3RCb3Qoe1xuICogICAgICAgbW9kZTogXCJMSVZFXCIsXG4gKiAgICAgICBhbGxvdzogW1wiQ0FURUdPUlk6U0VBUkNIX0VOR0lORVwiLCBcIkNVUkxcIl1cbiAqICAgICB9KVxuICogICBdLFxuICogfSk7XG4gKiBgYGBcbiAqIEBleGFtcGxlXG4gKiBEZW5pZXMgQUkgY3Jhd2xlcnMsIGFsbG93cyBhbGwgb3RoZXIgYm90c1xuICpcbiAqIGBgYHRzXG4gKiBkZXRlY3RCb3QoeyBtb2RlOiBcIkxJVkVcIiwgZGVueTogW1wiQ0FURUdPUlk6QUlcIl0gfSk7XG4gKiBgYGBcbiAqIEBleGFtcGxlXG4gKiBEZW5pZXMgQUkgY3Jhd2xlcnMsIGFsbG93cyBhbGwgb3RoZXIgYm90c1xuICogYGBgdHNcbiAqIGNvbnN0IGFqID0gYXJjamV0KHtcbiAqICAga2V5OiBwcm9jZXNzLmVudi5BUkNKRVRfS0VZLFxuICogICBydWxlczogW1xuICogICAgIGRldGVjdEJvdCh7XG4gKiAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgIGRlbnk6IFtcIkNBVEVHT1JZOkFJXCJdXG4gKiAgICAgfSlcbiAqICAgXSxcbiAqIH0pO1xuICogYGBgXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9ib3QtcHJvdGVjdGlvbi9jb25jZXB0c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vYm90LXByb3RlY3Rpb24vaWRlbnRpZnlpbmctYm90c1xuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vYm90LXByb3RlY3Rpb24vcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIGRldGVjdEJvdChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVCb3RPcHRpb25zKG9wdGlvbnMpO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBkZXRlY3RCb3RgIG9wdGlvbnMgZXJyb3I6IGBhbGxvd2AgYW5kIGBkZW55YCBjYW5ub3QgYmUgcHJvdmlkZWQgdG9nZXRoZXJcIik7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5hbGxvdyA9PT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0eXBlb2Ygb3B0aW9ucy5kZW55ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImBkZXRlY3RCb3RgIG9wdGlvbnMgZXJyb3I6IGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCBtdXN0IGJlIHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY29uc3QgdHlwZSA9IFwiQk9UXCI7XG4gICAgY29uc3QgdmVyc2lvbiA9IDA7XG4gICAgY29uc3QgbW9kZSA9IG9wdGlvbnMubW9kZSA9PT0gXCJMSVZFXCIgPyBcIkxJVkVcIiA6IFwiRFJZX1JVTlwiO1xuICAgIGNvbnN0IGFsbG93ID0gb3B0aW9ucy5hbGxvdyA/PyBbXTtcbiAgICBjb25zdCBkZW55ID0gb3B0aW9ucy5kZW55ID8/IFtdO1xuICAgIGNvbnN0IGlkID0gaGFzaGVyLmhhc2goaGFzaGVyLnN0cmluZyhcInR5cGVcIiwgdHlwZSksIGhhc2hlci51aW50MzIoXCJ2ZXJzaW9uXCIsIHZlcnNpb24pLCBoYXNoZXIuc3RyaW5nKFwibW9kZVwiLCBtb2RlKSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImFsbG93XCIsIGFsbG93KSwgaGFzaGVyLnN0cmluZ1NsaWNlT3JkZXJlZChcImRlbnlcIiwgZGVueSkpO1xuICAgIGxldCBjb25maWcgPSB7XG4gICAgICAgIHRhZzogXCJhbGxvd2VkLWJvdC1jb25maWdcIixcbiAgICAgICAgdmFsOiB7XG4gICAgICAgICAgICBlbnRpdGllczogW10sXG4gICAgICAgICAgICBza2lwQ3VzdG9tRGV0ZWN0OiB0cnVlLFxuICAgICAgICB9LFxuICAgIH07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmFsbG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHRhZzogXCJhbGxvd2VkLWJvdC1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzOiBvcHRpb25zLmFsbG93LFxuICAgICAgICAgICAgICAgIHNraXBDdXN0b21EZXRlY3Q6IHRydWUsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVueSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICB0YWc6IFwiZGVuaWVkLWJvdC1jb25maWdcIixcbiAgICAgICAgICAgIHZhbDoge1xuICAgICAgICAgICAgICAgIGVudGl0aWVzOiBvcHRpb25zLmRlbnksXG4gICAgICAgICAgICAgICAgc2tpcEN1c3RvbURldGVjdDogdHJ1ZSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSB7XG4gICAgICAgIHZlcnNpb24sXG4gICAgICAgIHByaW9yaXR5OiBQcmlvcml0eS5Cb3REZXRlY3Rpb24sXG4gICAgICAgIHR5cGUsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIGFsbG93LFxuICAgICAgICBkZW55LFxuICAgICAgICB2YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGRldGFpbHMuaGVhZGVycyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJvdCBkZXRlY3Rpb24gcmVxdWlyZXMgYGhlYWRlcnNgIHRvIGJlIHNldFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGV0YWlscy5oZWFkZXJzLmhhcyAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYm90IGRldGVjdGlvbiByZXF1aXJlcyBgaGVhZGVyc2AgdG8gZXh0ZW5kIGBIZWFkZXJzYFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGV0YWlscy5oZWFkZXJzLmhhcyhcInVzZXItYWdlbnRcIikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJib3QgZGV0ZWN0aW9uIHJlcXVpcmVzIHVzZXItYWdlbnQgaGVhZGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQXR0ZW1wdHMgdG8gY2FsbCB0aGUgYm90IGRldGVjdGlvbiBvbiB0aGUgaGVhZGVycy5cbiAgICAgICAgICovXG4gICAgICAgIGFzeW5jIHByb3RlY3QoY29udGV4dCwgcmVxdWVzdCkge1xuICAgICAgICAgICAgY29uc3QgcnVsZUlkID0gYXdhaXQgaWQ7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBhbmFseXplLmRldGVjdEJvdChjb250ZXh0LCB0b0FuYWx5emVSZXF1ZXN0KHJlcXVlc3QpLCBjb25maWcpO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSBtb2RlID09PSBcIkxJVkVcIiA/IFwiUlVOXCIgOiBcIkRSWV9SVU5cIjtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgaXMgYSBib3QgYW5kIG9mIGEgdHlwZSB0aGF0IHdlIHdhbnQgdG8gYmxvY2ssIHRoZW4gYmxvY2shXG4gICAgICAgICAgICBpZiAocmVzdWx0LmRlbmllZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcmNqZXRSdWxlUmVzdWx0KHtcbiAgICAgICAgICAgICAgICAgICAgcnVsZUlkLFxuICAgICAgICAgICAgICAgICAgICB0dGw6IDYwLFxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJERU5ZXCIsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEJvdFJlYXNvbih7XG4gICAgICAgICAgICAgICAgICAgICAgICBhbGxvd2VkOiByZXN1bHQuYWxsb3dlZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbmllZDogcmVzdWx0LmRlbmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZlcmlmaWVkOiByZXN1bHQudmVyaWZpZWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBzcG9vZmVkOiByZXN1bHQuc3Bvb2ZlZCxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICBydWxlSWQsXG4gICAgICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0Qm90UmVhc29uKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFsbG93ZWQ6IHJlc3VsdC5hbGxvd2VkLFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVuaWVkOiByZXN1bHQuZGVuaWVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmVyaWZpZWQ6IHJlc3VsdC52ZXJpZmllZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwb29mZWQ6IHJlc3VsdC5zcG9vZmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9O1xuICAgIHJldHVybiBbcnVsZV07XG59XG4vKipcbiAqIEFyY2pldCBTaGllbGQgV0FGIHJ1bGUuIEFwcGx5aW5nIHRoaXMgcnVsZSBwcm90ZWN0cyB5b3VyIGFwcGxpY2F0aW9uIGFnYWluc3RcbiAqIGNvbW1vbiBhdHRhY2tzLCBpbmNsdWRpbmcgdGhlIE9XQVNQIFRvcCAxMC5cbiAqXG4gKiBUaGUgQXJjamV0IFNoaWVsZCBXQUYgYW5hbHl6ZXMgZXZlcnkgcmVxdWVzdCB0byB5b3VyIGFwcGxpY2F0aW9uIHRvIGRldGVjdFxuICogc3VzcGljaW91cyBhY3Rpdml0eS4gT25jZSBhIGNlcnRhaW4gc3VzcGljaW9uIHRocmVzaG9sZCBpcyByZWFjaGVkLFxuICogc3Vic2VxdWVudCByZXF1ZXN0cyBmcm9tIHRoYXQgY2xpZW50IGFyZSBibG9ja2VkIGZvciBhIHBlcmlvZCBvZiB0aW1lLlxuICpcbiAqIEBwYXJhbSB7U2hpZWxkT3B0aW9uc30gb3B0aW9ucyAtIFRoZSBvcHRpb25zIGZvciB0aGUgU2hpZWxkIHJ1bGUuXG4gKiBAcGFyYW0ge0FyY2pldE1vZGV9IG9wdGlvbnMubW9kZSAtIFRoZSBibG9jayBtb2RlIG9mIHRoZSBydWxlLCBlaXRoZXJcbiAqIGBcIkxJVkVcImAgb3IgYFwiRFJZX1JVTlwiYC4gYFwiTElWRVwiYCB3aWxsIGJsb2NrIHN1c3BpY2lvdXMgcmVxdWVzdHMsIGFuZFxuICogYFwiRFJZX1JVTlwiYCB3aWxsIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbCBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSBydWxlXG4gKiByZXN1bHRzLiBEZWZhdWx0cyB0byBgXCJEUllfUlVOXCJgIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcmV0dXJucyB7UHJpbWl0aXZlfSBUaGUgU2hpZWxkIHJ1bGUgdG8gcHJvdmlkZSB0byB0aGUgU0RLIGluIHRoZSBgcnVsZXNgXG4gKiBvcHRpb24uXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBzaGllbGQoeyBtb2RlOiBcIkxJVkVcIiB9KTtcbiAqIGBgYFxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtzaGllbGQoeyBtb2RlOiBcIkxJVkVcIiB9KV0sXG4gKiB9KTtcbiAqIGBgYFxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vc2hpZWxkL2NvbmNlcHRzXG4gKiBAbGluayBodHRwczovL2RvY3MuYXJjamV0LmNvbS9zaGllbGQvcmVmZXJlbmNlXG4gKi9cbmZ1bmN0aW9uIHNoaWVsZChvcHRpb25zKSB7XG4gICAgdmFsaWRhdGVTaGllbGRPcHRpb25zKG9wdGlvbnMpO1xuICAgIGNvbnN0IHR5cGUgPSBcIlNISUVMRFwiO1xuICAgIGNvbnN0IHZlcnNpb24gPSAwO1xuICAgIGNvbnN0IG1vZGUgPSBvcHRpb25zLm1vZGUgPT09IFwiTElWRVwiID8gXCJMSVZFXCIgOiBcIkRSWV9SVU5cIjtcbiAgICBjb25zdCBydWxlID0ge1xuICAgICAgICB0eXBlLFxuICAgICAgICB2ZXJzaW9uLFxuICAgICAgICBwcmlvcml0eTogUHJpb3JpdHkuU2hpZWxkLFxuICAgICAgICBtb2RlLFxuICAgIH07XG4gICAgcmV0dXJuIFtydWxlXTtcbn1cbi8qKlxuICogQXJjamV0IHNpZ251cCBmb3JtIHByb3RlY3Rpb24gcnVsZS4gQXBwbHlpbmcgdGhpcyBydWxlIGNvbWJpbmVzIHJhdGVcbiAqIGxpbWl0aW5nLCBib3QgcHJvdGVjdGlvbiwgYW5kIGVtYWlsIHZhbGlkYXRpb24gdG8gcHJvdGVjdCB5b3VyIHNpZ251cCBmb3Jtc1xuICogZnJvbSBhYnVzZS4gVXNpbmcgdGhpcyBydWxlIHdpbGwgY29uZmlndXJlIHRoZSBmb2xsb3dpbmc6XG4gKlxuICogLSBSYXRlIGxpbWl0aW5nIC0gc2lnbnVwIGZvcm1zIGFyZSBhIGNvbW1vbiB0YXJnZXQgZm9yIGJvdHMuIEFyY2pldOKAmXMgcmF0ZVxuICogICBsaW1pdGluZyBoZWxwcyB0byBwcmV2ZW50IGJvdHMgYW5kIG90aGVyIGF1dG9tYXRlZCBvciBtYWxpY2lvdXMgY2xpZW50c1xuICogICBmcm9tIHN1Ym1pdHRpbmcgeW91ciBzaWdudXAgZm9ybSB0b28gbWFueSB0aW1lcyBpbiBhIHNob3J0IHBlcmlvZCBvZiB0aW1lLlxuICogLSBCb3QgcHJvdGVjdGlvbiAtIHNpZ251cCBmb3JtcyBhcmUgdXN1YWxseSBleGNsdXNpdmVseSB1c2VkIGJ5IGh1bWFucywgd2hpY2hcbiAqICAgbWVhbnMgdGhhdCBhbnkgYXV0b21hdGVkIHN1Ym1pc3Npb25zIHRvIHRoZSBmb3JtIGFyZSBsaWtlbHkgdG8gYmVcbiAqICAgZnJhdWR1bGVudC5cbiAqIC0gRW1haWwgdmFsaWRhdGlvbiAtIGVtYWlsIGFkZHJlc3NlcyBzaG91bGQgYmUgdmFsaWRhdGVkIHRvIGVuc3VyZSB0aGUgc2lnbnVwXG4gKiAgIGlzIGNvbWluZyBmcm9tIGEgbGVnaXRpbWF0ZSB1c2VyIHdpdGggYSByZWFsIGVtYWlsIGFkZHJlc3MgdGhhdCBjYW5cbiAqICAgYWN0dWFsbHkgcmVjZWl2ZSBtZXNzYWdlcy5cbiAqXG4gKiBAcGFyYW0ge1Byb3RlY3RTaWdudXBPcHRpb25zfSBvcHRpb25zIC0gVGhlIG9wdGlvbnMgZm9yIHRoZSBzaWdudXAgZm9ybVxuICogcHJvdGVjdGlvbiBydWxlLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLmVtYWlsLm1vZGUgLSBUaGUgYmxvY2sgbW9kZSBvZiB0aGUgcnVsZSwgZWl0aGVyXG4gKiBgXCJMSVZFXCJgIG9yIGBcIkRSWV9SVU5cImAuIGBcIkxJVkVcImAgd2lsbCBibG9jayBlbWFpbCBhZGRyZXNzZXMgYmFzZWQgb24gdGhlXG4gKiBjb25maWd1cmF0aW9uLCBhbmQgYFwiRFJZX1JVTlwiYCB3aWxsIGFsbG93IGFsbCByZXF1ZXN0cyB3aGlsZSBzdGlsbCBwcm92aWRpbmdcbiAqIGFjY2VzcyB0byB0aGUgcnVsZSByZXN1bHRzLiBEZWZhdWx0cyB0byBgXCJEUllfUlVOXCJgIGlmIG5vdCBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldEVtYWlsVHlwZT59IG9wdGlvbnMuZW1haWwuZGVueSAtIFRoZSBsaXN0IG9mIGVtYWlsIHR5cGVzXG4gKiB0byBkZW55LiBJZiBwcm92aWRlZCwgdGhlIGVtYWlsIHR5cGVzIGluIHRoaXMgbGlzdCB3aWxsIGJlIGRlbmllZC4gWW91IG1heVxuICogb25seSBwcm92aWRlIGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCwgbm90IGJvdGguIFNwZWNpZnkgb25lIG9yIG1vcmUgb2YgdGhlXG4gKiBmb2xsb3dpbmc6XG4gKlxuICogLSBgXCJESVNQT1NBQkxFXCJgIC0gRGlzcG9zYWJsZSBlbWFpbCBhZGRyZXNzZXMuXG4gKiAtIGBcIkZSRUVcImAgLSBGcmVlIGVtYWlsIGFkZHJlc3Nlcy5cbiAqIC0gYFwiTk9fTVhfUkVDT1JEU1wiYCAtIEVtYWlsIGFkZHJlc3NlcyB3aXRoIG5vIE1YIHJlY29yZHMuXG4gKiAtIGBcIk5PX0dSQVZBVEFSXCJgIC0gRW1haWwgYWRkcmVzc2VzIHdpdGggbm8gR3JhdmF0YXIuXG4gKiAtIGBcIklOVkFMSURcImAgLSBJbnZhbGlkIGVtYWlsIGFkZHJlc3Nlcy5cbiAqXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldEVtYWlsVHlwZT59IG9wdGlvbnMuZW1haWwuYWxsb3cgLSBUaGUgbGlzdCBvZiBlbWFpbCB0eXBlc1xuICogdG8gYWxsb3cuIElmIHByb3ZpZGVkLCBlbWFpbCBhZGRyZXNzZXMgaW4gdGhpcyBsaXN0IHdpbGwgYmUgYWxsb3dlZCBhbmQgYWxsXG4gKiBvdGhlcnMgd2lsbCBiZSBkZW5pZWQuIFlvdSBtYXkgb25seSBwcm92aWRlIGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCwgbm90XG4gKiBib3RoLiBUaGUgc2FtZSBvcHRpb25zIGFwcGx5IGFzIGZvciBgZGVueWAuXG4gKiBAcGFyYW0ge0FyY2pldE1vZGV9IG9wdGlvbnMuYm90cy5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsIGVpdGhlclxuICogYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgZGV0ZWN0ZWQgYm90cywgYW5kIGBcIkRSWV9SVU5cImBcbiAqIHdpbGwgYWxsb3cgYWxsIHJlcXVlc3RzIHdoaWxlIHN0aWxsIHByb3ZpZGluZyBhY2Nlc3MgdG8gdGhlIHJ1bGUgcmVzdWx0cy5cbiAqIERlZmF1bHRzIHRvIGBcIkRSWV9SVU5cImAgaWYgbm90IHNwZWNpZmllZC5cbiAqIEBwYXJhbSB7QXJyYXk8QXJjamV0V2VsbEtub3duQm90IHwgQXJjamV0Qm90Q2F0ZWdvcnk+fSBvcHRpb25zLmJvdHMuYWxsb3cgLVxuICogVGhlIGxpc3Qgb2YgYm90cyB0byBhbGxvdy4gSWYgcHJvdmlkZWQsIG9ubHkgdGhlIGJvdHMgaW4gdGhpcyBsaXN0IHdpbGwgYmVcbiAqIGFsbG93ZWQgYW5kIGFueSBvdGhlciBkZXRlY3RlZCBib3Qgd2lsbCBiZSBkZW5pZWQuIElmIGVtcHR5LCBhbGwgYm90cyB3aWxsIGJlXG4gKiBkZW5pZWQuIFlvdSBtYXkgb25seSBwcm92aWRlIGVpdGhlciBgYWxsb3dgIG9yIGBkZW55YCwgbm90IGJvdGguIFlvdSBjYW4gdXNlXG4gKiBzcGVjaWZpYyBib3RzIGUuZy4gYFwiQ1VSTFwiYCB3aWxsIGFsbG93IHRoZSBkZWZhdWx0IHVzZXItYWdlbnQgb2YgdGhlIGBjdXJsYFxuICogdG9vbC4gWW91IGNhbiBhbHNvIHVzZSBjYXRlZ29yaWVzIGUuZy4gYFwiQ0FURUdPUlk6U0VBUkNIX0VOR0lORVwiYCB3aWxsIGFsbG93XG4gKiBhbGwgc2VhcmNoIGVuZ2luZSBib3RzLiBTZWVcbiAqIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL2JvdC1wcm90ZWN0aW9uL2lkZW50aWZ5aW5nLWJvdHMgZm9yIHRoZSBmdWxsIGxpc3Qgb2ZcbiAqIGJvdHMgYW5kIGNhdGVnb3JpZXMuXG4gKiBAcGFyYW0ge0FycmF5PEFyY2pldFdlbGxLbm93bkJvdCB8IEFyY2pldEJvdENhdGVnb3J5Pn0gb3B0aW9ucy5ib3RzLmRlbnkgLVxuICogVGhlIGxpc3Qgb2YgYm90cyB0byBkZW55LiBJZiBwcm92aWRlZCwgdGhlIGJvdHMgaW4gdGhpcyBsaXN0IHdpbGwgYmUgZGVuaWVkXG4gKiBhbmQgYWxsIG90aGVyIGRldGVjdGVkIGJvdHMgd2lsbCBiZSBhbGxvd2VkLiBZb3UgbWF5IG9ubHkgcHJvdmlkZSBlaXRoZXJcbiAqIGBhbGxvd2Agb3IgYGRlbnlgLCBub3QgYm90aC4gVGhlIHNhbWUgb3B0aW9ucyBhcHBseSBhcyBmb3IgYGFsbG93YC5cbiAqIEBwYXJhbSB7U2xpZGluZ1dpbmRvd1JhdGVMaW1pdE9wdGlvbnN9IG9wdGlvbnMucmF0ZUxpbWl0IC0gVGhlIG9wdGlvbnMgZm9yXG4gKiB0aGUgc2xpZGluZyB3aW5kb3cgcmF0ZSBsaW1pdGluZyBydWxlLlxuICogQHBhcmFtIHtBcmNqZXRNb2RlfSBvcHRpb25zLnJhdGVMaW1pdC5tb2RlIC0gVGhlIGJsb2NrIG1vZGUgb2YgdGhlIHJ1bGUsXG4gKiBlaXRoZXIgYFwiTElWRVwiYCBvciBgXCJEUllfUlVOXCJgLiBgXCJMSVZFXCJgIHdpbGwgYmxvY2sgcmVxdWVzdHMgd2hlbiB0aGUgcmF0ZVxuICogbGltaXQgaXMgZXhjZWVkZWQsIGFuZCBgXCJEUllfUlVOXCJgIHdpbGwgYWxsb3cgYWxsIHJlcXVlc3RzIHdoaWxlIHN0aWxsXG4gKiBwcm92aWRpbmcgYWNjZXNzIHRvIHRoZSBydWxlIHJlc3VsdHMuIERlZmF1bHRzIHRvIGBcIkRSWV9SVU5cImAgaWYgbm90XG4gKiBzcGVjaWZpZWQuXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gb3B0aW9ucy5yYXRlTGltaXQuaW50ZXJ2YWwgLSBUaGUgdGltZSBpbnRlcnZhbCBmb3JcbiAqIHRoZSByYXRlIGxpbWl0LiBUaGlzIGNhbiBiZSBhIHN0cmluZyBsaWtlIGBcIjYwc1wiYCBmb3IgNjAgc2Vjb25kcywgYFwiMWg0NW1cImBcbiAqIGZvciAxIGhvdXIgYW5kIDQ1IG1pbnV0ZXMsIG9yIGEgbnVtYmVyIGxpa2UgYDYwYCBmb3IgNjAgc2Vjb25kcy4gVmFsaWQgc3RyaW5nXG4gKiB0aW1lIHVuaXRzIGFyZTpcbiAqIC0gYHNgIGZvciBzZWNvbmRzLlxuICogLSBgbWAgZm9yIG1pbnV0ZXMuXG4gKiAtIGBoYCBmb3IgaG91cnMuXG4gKiAtIGBkYCBmb3IgZGF5cy5cbiAqIEBwYXJhbSB7bnVtYmVyfSBvcHRpb25zLnJhdGVMaW1pdC5tYXggLSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVxdWVzdHNcbiAqIGFsbG93ZWQgaW4gdGhlIHNsaWRpbmcgdGltZSB3aW5kb3cuXG4gKiBAcmV0dXJucyB7UHJpbWl0aXZlfSBUaGUgc2lnbnVwIGZvcm0gcHJvdGVjdGlvbiBydWxlIHRvIHByb3ZpZGUgdG8gdGhlIFNESyBpblxuICogdGhlIGBydWxlc2Agb3B0aW9uLlxuICpcbiAqIEBleGFtcGxlXG4gKiBPdXIgcmVjb21tZW5kZWQgY29uZmlndXJhdGlvbiBmb3IgbW9zdCBzaWdudXAgZm9ybXMgaXM6XG4gKlxuICogLSBCbG9jayBlbWFpbHMgd2l0aCBpbnZhbGlkIHN5bnRheCwgdGhhdCBhcmUgZnJvbSBkaXNwb3NhYmxlIGVtYWlsIHByb3ZpZGVycyxcbiAqICAgb3IgZG8gbm90IGhhdmUgdmFsaWQgTVggcmVjb3JkcyBjb25maWd1cmVkLlxuICogLSBCbG9jayBhbGwgYm90cy5cbiAqIC0gQXBwbHkgYSByYXRlIGxpbWl0IG9mIDUgc3VibWlzc2lvbnMgcGVyIDEwIG1pbnV0ZXMgZnJvbSBhIHNpbmdsZSBJUFxuICogICBhZGRyZXNzLlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBhaiA9IGFyY2pldCh7XG4gKiAgIGtleTogcHJvY2Vzcy5lbnYuQVJDSkVUX0tFWSxcbiAqICAgcnVsZXM6IFtcbiAqICAgIHByb3RlY3RTaWdudXAoe1xuICogICAgICBlbWFpbDoge1xuICogICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgIGJsb2NrOiBbXCJESVNQT1NBQkxFXCIsIFwiSU5WQUxJRFwiLCBcIk5PX01YX1JFQ09SRFNcIl0sXG4gKiAgICAgIH0sXG4gKiAgICAgIGJvdHM6IHtcbiAqICAgICAgICBtb2RlOiBcIkxJVkVcIixcbiAqICAgICAgICBhbGxvdzogW10sIC8vIGJsb2NrIGFsbCBkZXRlY3RlZCBib3RzXG4gKiAgICAgIH0sXG4gKiAgICAgIHJhdGVMaW1pdDoge1xuICogICAgICAgIG1vZGU6IFwiTElWRVwiLFxuICogICAgICAgIGludGVydmFsOiBcIjEwbVwiLFxuICogICAgICAgIG1heDogNSxcbiAqICAgICAgfSxcbiAqICAgIH0pLFxuICogIF0sXG4gKiB9KTtcbiAqIGBgYFxuICogQGxpbmsgaHR0cHM6Ly9kb2NzLmFyY2pldC5jb20vc2lnbnVwLXByb3RlY3Rpb24vY29uY2VwdHNcbiAqIEBsaW5rIGh0dHBzOi8vZG9jcy5hcmNqZXQuY29tL3NpZ251cC1wcm90ZWN0aW9uL3JlZmVyZW5jZVxuICovXG5mdW5jdGlvbiBwcm90ZWN0U2lnbnVwKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5zbGlkaW5nV2luZG93KG9wdGlvbnMucmF0ZUxpbWl0KSxcbiAgICAgICAgLi4uZGV0ZWN0Qm90KG9wdGlvbnMuYm90cyksXG4gICAgICAgIC4uLnZhbGlkYXRlRW1haWwob3B0aW9ucy5lbWFpbCksXG4gICAgXTtcbn1cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFyY2pldCBjbGllbnQgd2l0aCB0aGUgc3BlY2lmaWVkIHtAbGluayBBcmNqZXRPcHRpb25zfS5cbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyB7QXJjamV0T3B0aW9uc30gQXJjamV0IGNvbmZpZ3VyYXRpb24gb3B0aW9ucy5cbiAqL1xuZnVuY3Rpb24gYXJjamV0KG9wdGlvbnMpIHtcbiAgICAvLyBXZSBkZXN0cnVjdHVyZSBoZXJlIHRvIG1ha2UgdGhlIGZ1bmN0aW9uIHNpZ25hdHVyZSBuZWF0IHdoZW4gdmlld2VkIGJ5IGNvbnN1bWVyc1xuICAgIGNvbnN0IHsga2V5LCBydWxlcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBydCA9IHJ1bnRpbWUoKTtcbiAgICAvLyBUT0RPOiBTZXBhcmF0ZSB0aGUgQXJjamV0T3B0aW9ucyBmcm9tIHRoZSBTREsgT3B0aW9uc1xuICAgIC8vIEl0IGlzIGN1cnJlbnRseSBvcHRpb25hbCBpbiB0aGUgb3B0aW9ucyBzbyB1c2VycyBjYW4gb3ZlcnJpZGUgaXQgdmlhIGFuIFNES1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5sb2cgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9nIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBjb25zdCBsb2cgPSBvcHRpb25zLmxvZztcbiAgICBjb25zdCBwZXJmID0gbmV3IFBlcmZvcm1hbmNlKGxvZyk7XG4gICAgLy8gVE9ETygjMjA3KTogUmVtb3ZlIHRoaXMgd2hlbiB3ZSBjYW4gZGVmYXVsdCB0aGUgdHJhbnNwb3J0IHNvIGNsaWVudCBpcyBub3QgcmVxdWlyZWRcbiAgICAvLyBJdCBpcyBjdXJyZW50bHkgb3B0aW9uYWwgaW4gdGhlIG9wdGlvbnMgc28gdGhlIE5leHQgU0RLIGNhbiBvdmVycmlkZSBpdCBmb3IgdGhlIHVzZXJcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuY2xpZW50ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNsaWVudCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgY29uc3QgY2xpZW50ID0gb3B0aW9ucy5jbGllbnQ7XG4gICAgLy8gQSBsb2NhbCBjYWNoZSBvZiBibG9jayBkZWNpc2lvbnMuIE1pZ2h0IGJlIGVtcGhlbWVyYWwgcGVyIHJlcXVlc3QsXG4gICAgLy8gZGVwZW5kaW5nIG9uIHRoZSB3YXkgdGhlIHJ1bnRpbWUgd29ya3MsIGJ1dCBpdCdzIHdvcnRoIGEgdHJ5LlxuICAgIC8vIFRPRE8oIzEzMik6IFN1cHBvcnQgY29uZmlndXJhYmxlIGNhY2hpbmdcbiAgICBjb25zdCBibG9ja0NhY2hlID0gbmV3IENhY2hlKCk7XG4gICAgY29uc3Qgcm9vdFJ1bGVzID0gcnVsZXNcbiAgICAgICAgLmZsYXQoMSlcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGEucHJpb3JpdHkgLSBiLnByaW9yaXR5KTtcbiAgICBhc3luYyBmdW5jdGlvbiBwcm90ZWN0KHJ1bGVzLCBjdHgsIHJlcXVlc3QpIHtcbiAgICAgICAgLy8gVGhpcyBnb2VzIGFnYWluc3QgdGhlIHR5cGUgZGVmaW5pdGlvbiBhYm92ZSwgYnV0IHVzZXJzIG1pZ2h0IGNhbGxcbiAgICAgICAgLy8gYHByb3RlY3QoKWAgd2l0aCBubyB2YWx1ZSBhbmQgd2UgZG9uJ3Qgd2FudCB0byBjcmFzaFxuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHJlcXVlc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZXRhaWxzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICBpcDogcmVxdWVzdC5pcCxcbiAgICAgICAgICAgIG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG4gICAgICAgICAgICBwcm90b2NvbDogcmVxdWVzdC5wcm90b2NvbCxcbiAgICAgICAgICAgIGhvc3Q6IHJlcXVlc3QuaG9zdCxcbiAgICAgICAgICAgIHBhdGg6IHJlcXVlc3QucGF0aCxcbiAgICAgICAgICAgIGhlYWRlcnM6IG5ldyBBcmNqZXRIZWFkZXJzKHJlcXVlc3QuaGVhZGVycyksXG4gICAgICAgICAgICBjb29raWVzOiByZXF1ZXN0LmNvb2tpZXMsXG4gICAgICAgICAgICBxdWVyeTogcmVxdWVzdC5xdWVyeSxcbiAgICAgICAgICAgIC8vIFRPRE8oIzIwOCk6IFJlLWFkZCBib2R5XG4gICAgICAgICAgICAvLyBib2R5OiByZXF1ZXN0LmJvZHksXG4gICAgICAgICAgICBleHRyYTogZXh0cmFQcm9wcyhyZXF1ZXN0KSxcbiAgICAgICAgICAgIGVtYWlsOiB0eXBlb2YgcmVxdWVzdC5lbWFpbCA9PT0gXCJzdHJpbmdcIiA/IHJlcXVlc3QuZW1haWwgOiB1bmRlZmluZWQsXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBjaGFyYWN0ZXJpc3RpY3MgPSBvcHRpb25zLmNoYXJhY3RlcmlzdGljc1xuICAgICAgICAgICAgPyBbLi4ub3B0aW9ucy5jaGFyYWN0ZXJpc3RpY3NdXG4gICAgICAgICAgICA6IFtdO1xuICAgICAgICBjb25zdCB3YWl0VW50aWwgPSBsb29rdXBXYWl0VW50aWwoKTtcbiAgICAgICAgY29uc3QgYmFzZUNvbnRleHQgPSB7XG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBsb2csXG4gICAgICAgICAgICBjaGFyYWN0ZXJpc3RpY3MsXG4gICAgICAgICAgICB3YWl0VW50aWwsXG4gICAgICAgICAgICAuLi5jdHgsXG4gICAgICAgIH07XG4gICAgICAgIGxldCBmaW5nZXJwcmludCA9IFwiXCI7XG4gICAgICAgIGNvbnN0IGxvZ0ZpbmdlcnByaW50UGVyZiA9IHBlcmYubWVhc3VyZShcImZpbmdlcnByaW50XCIpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZmluZ2VycHJpbnQgPSBhd2FpdCBhbmFseXplLmdlbmVyYXRlRmluZ2VycHJpbnQoYmFzZUNvbnRleHQsIHRvQW5hbHl6ZVJlcXVlc3QoZGV0YWlscykpO1xuICAgICAgICAgICAgbG9nLmRlYnVnKFwiZmluZ2VycHJpbnQgKCVzKTogJXNcIiwgcnQsIGZpbmdlcnByaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGxvZy5lcnJvcih7IGVycm9yIH0sIFwiRmFpbGVkIHRvIGJ1aWxkIGZpbmdlcnByaW50LiBQbGVhc2UgdmVyaWZ5IHlvdXIgQ2hhcmFjdGVyaXN0aWNzLlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGRlY2lzaW9uID0gbmV3IEFyY2pldEVycm9yRGVjaXNpb24oe1xuICAgICAgICAgICAgICAgIHR0bDogMCxcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRFcnJvclJlYXNvbihgRmFpbGVkIHRvIGJ1aWxkIGZpbmdlcnByaW50IC0gJHtlcnJvck1lc3NhZ2UoZXJyb3IpfWApLFxuICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdHMgYmVjYXVzZSB3ZSBjb3VsZG4ndCBjcmVhdGUgYSBmaW5nZXJwcmludFxuICAgICAgICAgICAgICAgIHJlc3VsdHM6IFtdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBUT0RPOiBDb25zaWRlciBzZW5kaW5nIHRoaXMgdG8gUmVwb3J0IHdoZW4gd2UgaGF2ZSBhbiBpbmZhbGxpYmxlIGZpbmdlcnByaW50XG4gICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBsb2dGaW5nZXJwcmludFBlcmYoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb250ZXh0ID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAuLi5iYXNlQ29udGV4dCxcbiAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnVsZXMubGVuZ3RoIDwgMSkge1xuICAgICAgICAgICAgbG9nLndhcm4oXCJDYWxsaW5nIGBwcm90ZWN0KClgIHdpdGggbm8gcnVsZXMgaXMgZGVwcmVjYXRlZC4gRGlkIHlvdSBtZWFuIHRvIGNvbmZpZ3VyZSB0aGUgU2hpZWxkIHJ1bGU/XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlcy5sZW5ndGggPiAxMCkge1xuICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGVzLiBPbmx5IDEwIHJ1bGVzIG1heSBiZSBzcGVjaWZpZWQuXCIpO1xuICAgICAgICAgICAgY29uc3QgZGVjaXNpb24gPSBuZXcgQXJjamV0RXJyb3JEZWNpc2lvbih7XG4gICAgICAgICAgICAgICAgdHRsOiAwLFxuICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwiT25seSAxMCBydWxlcyBtYXkgYmUgc3BlY2lmaWVkXCIpLFxuICAgICAgICAgICAgICAgIC8vIE5vIHJlc3VsdHMgYmVjYXVzZSB0aGUgc29ydGVkIHJ1bGVzIHdlcmUgdG9vIGxvbmcgYW5kIHdlIGRvbid0IHdhbnRcbiAgICAgICAgICAgICAgICAvLyB0byBpbnN0YW50aWF0ZSBhIHRvbiBvZiBOT1RfUlVOIHJlc3VsdHNcbiAgICAgICAgICAgICAgICByZXN1bHRzOiBbXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgXG4gICAgICAgICAgICAvLyBObyBydWxlcyBiZWNhdXNlIHdlJ3ZlIGRldGVybWluZWQgdGhleSB3ZXJlIHRvbyBsb25nIGFuZCB3ZSBkb24ndFxuICAgICAgICAgICAgLy8gd2FudCB0byB0cnkgdG8gc2VuZCB0aGVtIHRvIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIFtdKTtcbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHJ1bGVzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIC8vIERlZmF1bHQgYWxsIHJ1bGVzIHRvIE5PVF9SVU4vQUxMT1cgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgICAgICByZXN1bHRzW2lkeF0gPSBuZXcgQXJjamV0UnVsZVJlc3VsdCh7XG4gICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IEZpZ3VyZSBvdXQgaWYgd2UgY2FuIGdldCBlYWNoIFJ1bGUgSUQgYmVmb3JlIHRoZXkgYXJlIHJ1blxuICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgc3RhdGU6IFwiTk9UX1JVTlwiLFxuICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiQUxMT1dcIixcbiAgICAgICAgICAgICAgICByZWFzb246IG5ldyBBcmNqZXRSZWFzb24oKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQWRkIHRvcC1sZXZlbCBjaGFyYWN0ZXJpc3RpY3MgdG8gYWxsIFJhdGUgTGltaXQgcnVsZXMgdGhhdCBkb24ndCBhbHJlYWR5IGhhdmVcbiAgICAgICAgICAgIC8vIHRoZWlyIG93biBzZXQgb2YgY2hhcmFjdGVyaXN0aWNzLlxuICAgICAgICAgICAgY29uc3QgY2FuZGlkYXRlX3J1bGUgPSBydWxlc1tpZHhdO1xuICAgICAgICAgICAgaWYgKGlzUmF0ZUxpbWl0UnVsZShjYW5kaWRhdGVfcnVsZSkpIHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNhbmRpZGF0ZV9ydWxlLmNoYXJhY3RlcmlzdGljcyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVfcnVsZS5jaGFyYWN0ZXJpc3RpY3MgPSBjaGFyYWN0ZXJpc3RpY3M7XG4gICAgICAgICAgICAgICAgICAgIHJ1bGVzW2lkeF0gPSBjYW5kaWRhdGVfcnVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbG9nTG9jYWxQZXJmID0gcGVyZi5tZWFzdXJlKFwibG9jYWxcIik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXZSBoYXZlIG91ciBvd24gbG9jYWwgY2FjaGUgd2hpY2ggd2UgY2hlY2sgZmlyc3QuIFRoaXMgZG9lc24ndCB3b3JrIGluXG4gICAgICAgICAgICAvLyBzZXJ2ZXJsZXNzIGVudmlyb25tZW50cyB3aGVyZSBldmVyeSByZXF1ZXN0IGlzIGlzb2xhdGVkLCBidXQgdGhlcmUgbWF5IGJlXG4gICAgICAgICAgICAvLyBzb21lIGluc3RhbmNlcyB3aGVyZSB0aGUgaW5zdGFuY2UgaXMgbm90IHJlY3ljbGVkIGltbWVkaWF0ZWx5LiBJZiBzbywgd2VcbiAgICAgICAgICAgIC8vIGNhbiB0YWtlIGFkdmFudGFnZSBvZiB0aGF0LlxuICAgICAgICAgICAgY29uc3QgbG9nQ2FjaGVQZXJmID0gcGVyZi5tZWFzdXJlKFwiY2FjaGVcIik7XG4gICAgICAgICAgICBjb25zdCBleGlzdGluZ0Jsb2NrUmVhc29uID0gYmxvY2tDYWNoZS5nZXQoZmluZ2VycHJpbnQpO1xuICAgICAgICAgICAgbG9nQ2FjaGVQZXJmKCk7XG4gICAgICAgICAgICAvLyBJZiBhbHJlYWR5IGJsb2NrZWQgdGhlbiB3ZSBjYW4gYXN5bmMgbG9nIHRvIHRoZSBBUEkgYW5kIHJldHVybiB0aGVcbiAgICAgICAgICAgIC8vIGRlY2lzaW9uIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgaWYgKGV4aXN0aW5nQmxvY2tSZWFzb24pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXREZW55RGVjaXNpb24oe1xuICAgICAgICAgICAgICAgICAgICB0dGw6IGJsb2NrQ2FjaGUudHRsKGZpbmdlcnByaW50KSxcbiAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBleGlzdGluZ0Jsb2NrUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAvLyBBbGwgcmVzdWx0cyB3aWxsIGJlIE5PVF9SVU4gYmVjYXVzZSB3ZSB1c2VkIGEgY2FjaGVkIGRlY2lzaW9uXG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgcnVsZXMpO1xuICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBkZWNpc2lvbi5pZCxcbiAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogZGVjaXNpb24uY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZXhpc3RpbmdCbG9ja1JlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgICAgICAgICAgfSwgXCJkZWNpZGU6IGFscmVhZHkgYmxvY2tlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtpZHgsIHJ1bGVdIG9mIHJ1bGVzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgICAgIC8vIFRoaXMgcmUtYXNzaWdubWVudCBpcyBhIHdvcmthcm91bmQgdG8gYSBUeXBlU2NyaXB0IGVycm9yIHdpdGhcbiAgICAgICAgICAgICAgICAvLyBhc3NlcnRpb25zIHdoZXJlIHRoZSBuYW1lIHdhcyBpbnRyb2R1Y2VkIHZpYSBhIGRlc3RydWN0dXJlXG4gICAgICAgICAgICAgICAgbGV0IGxvY2FsUnVsZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNMb2NhbFJ1bGUocnVsZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxSdWxlID0gcnVsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBsb2dSdWxlUGVyZiA9IHBlcmYubWVhc3VyZShydWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2FsUnVsZS52YWxpZGF0ZShjb250ZXh0LCBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gYXdhaXQgbG9jYWxSdWxlLnByb3RlY3QoY29udGV4dCwgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIGEgcnVsZSBkaWRuJ3QgcmV0dXJuIGEgcnVsZSByZXN1bHQsIHdlIG5lZWQgdG8gc3R1YiBpdCB0byBhdm9pZFxuICAgICAgICAgICAgICAgICAgICAvLyBjcmFzaGluZy4gVGhpcyBzaG91bGQgb25seSBoYXBwZW4gaWYgYSB1c2VyIHdyaXRlcyBhIGN1c3RvbSBsb2NhbFxuICAgICAgICAgICAgICAgICAgICAvLyBydWxlIGluY29ycmVjdGx5LlxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHJlc3VsdHNbaWR4XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8oIzQwMzApOiBJZiB3ZSBjYW4gZ2V0IHRoZSBSdWxlIElEIGJlZm9yZSBydW5uaW5nIHJ1bGVzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY2FuIHVzZSBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGVJZDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGU6IFwiUlVOXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2x1c2lvbjogXCJFUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKFwicnVsZSByZXN1bHQgbWlzc2luZ1wiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGxvZy5kZWJ1Zyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogcmVzdWx0c1tpZHhdLnJ1bGVJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bGU6IHJ1bGUudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgcGF0aDogZGV0YWlscy5wYXRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnVudGltZTogcnQsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IHJlc3VsdHNbaWR4XS50dGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25jbHVzaW9uOiByZXN1bHRzW2lkeF0uY29uY2x1c2lvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogcmVzdWx0c1tpZHhdLnJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgfSwgXCJMb2NhbCBydWxlIHJlc3VsdDpcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nLmVycm9yKFwiRmFpbHVyZSBydW5uaW5nIHJ1bGU6ICVzIGR1ZSB0byAlc1wiLCBydWxlLnR5cGUsIGVycm9yTWVzc2FnZShlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0c1tpZHhdID0gbmV3IEFyY2pldFJ1bGVSZXN1bHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETygjNDAzMCk6IEZpZ3VyZSBvdXQgaWYgd2UgY2FuIGdldCBhIFJ1bGUgSUQgaW4gdGhpcyBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBydWxlSWQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZTogXCJSVU5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IFwiRVJST1JcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogbmV3IEFyY2pldEVycm9yUmVhc29uKGVyciksXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgbG9nUnVsZVBlcmYoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbaWR4XS5pc0RlbmllZCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZSBydWxlIGlzIG5vdCBhIERSWV9SVU4sIHdlIHdhbnQgdG8gY2FjaGUgbm9uLXplcm8gVFRMIHJlc3VsdHNcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIHJldHVybiBhIERFTlkgZGVjaXNpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzW2lkeF0uc3RhdGUgIT09IFwiRFJZX1JVTlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXREZW55RGVjaXNpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR0bDogcmVzdWx0c1tpZHhdLnR0bCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlc3VsdHNbaWR4XS5yZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gT25seSBhIERFTlkgZGVjaXNpb24gaXMgcmVwb3J0ZWQgdG8gYXZvaWQgY3JlYXRpbmcgMiBlbnRyaWVzIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYSByZXF1ZXN0LiBVcG9uIEFMTE9XLCB0aGUgYGRlY2lkZWAgY2FsbCB3aWxsIGNyZWF0ZSBhbiBlbnRyeSBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSByZXF1ZXN0LlxuICAgICAgICAgICAgICAgICAgICAgICAgY2xpZW50LnJlcG9ydChjb250ZXh0LCBkZXRhaWxzLCBkZWNpc2lvbiwgcnVsZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdHNbaWR4XS50dGwgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmRlYnVnKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmluZ2VycHJpbnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNsdXNpb246IGRlY2lzaW9uLmNvbmNsdXNpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYXNvbjogZGVjaXNpb24ucmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIFwiQ2FjaGluZyBkZWNpc2lvbiBmb3IgJWQgc2Vjb25kc1wiLCBkZWNpc2lvbi50dGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrQ2FjaGUuc2V0KGZpbmdlcnByaW50LCBkZWNpc2lvbi5yZWFzb24sIG5vd0luU2Vjb25kcygpICsgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsb2cud2FybihgRHJ5IHJ1biBtb2RlIGlzIGVuYWJsZWQgZm9yIFwiJXNcIiBydWxlLiBPdmVycmlkaW5nIGRlY2lzaW9uLiBEZWNpc2lvbiB3YXM6IERFTllgLCBydWxlLnR5cGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGxvZ0xvY2FsUGVyZigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdpdGggbm8gY2FjaGVkIHZhbHVlcywgd2UgdGFrZSBhIGRlY2lzaW9uIHJlbW90ZWx5LiBXZSB1c2UgYSB0aW1lb3V0IHRvXG4gICAgICAgIC8vIGZhaWwgb3Blbi5cbiAgICAgICAgY29uc3QgbG9nUmVtb3RlUGVyZiA9IHBlcmYubWVhc3VyZShcInJlbW90ZVwiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IGxvZ0RlZGljZUFwaVBlcmYgPSBwZXJmLm1lYXN1cmUoXCJkZWNpZGVBcGlcIik7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IGF3YWl0IGNsaWVudFxuICAgICAgICAgICAgICAgIC5kZWNpZGUoY29udGV4dCwgZGV0YWlscywgcnVsZXMpXG4gICAgICAgICAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGxvZ0RlZGljZUFwaVBlcmYoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gSWYgdGhlIGRlY2lzaW9uIGlzIHRvIGJsb2NrIGFuZCB3ZSBoYXZlIGEgbm9uLXplcm8gVFRMLCB3ZSBjYWNoZSB0aGVcbiAgICAgICAgICAgIC8vIGJsb2NrIGxvY2FsbHlcbiAgICAgICAgICAgIGlmIChkZWNpc2lvbi5pc0RlbmllZCgpICYmIGRlY2lzaW9uLnR0bCA+IDApIHtcbiAgICAgICAgICAgICAgICBsb2cuZGVidWcoXCJkZWNpZGU6IENhY2hpbmcgYmxvY2sgbG9jYWxseSBmb3IgJWQgc2Vjb25kc1wiLCBkZWNpc2lvbi50dGwpO1xuICAgICAgICAgICAgICAgIGJsb2NrQ2FjaGUuc2V0KGZpbmdlcnByaW50LCBkZWNpc2lvbi5yZWFzb24sIG5vd0luU2Vjb25kcygpICsgZGVjaXNpb24udHRsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBkZWNpc2lvbjtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBsb2cuZXJyb3IoXCJFbmNvdW50ZXJlZCBwcm9ibGVtIGdldHRpbmcgcmVtb3RlIGRlY2lzaW9uOiAlc1wiLCBlcnJvck1lc3NhZ2UoZXJyKSk7XG4gICAgICAgICAgICBjb25zdCBkZWNpc2lvbiA9IG5ldyBBcmNqZXRFcnJvckRlY2lzaW9uKHtcbiAgICAgICAgICAgICAgICB0dGw6IDAsXG4gICAgICAgICAgICAgICAgcmVhc29uOiBuZXcgQXJjamV0RXJyb3JSZWFzb24oZXJyKSxcbiAgICAgICAgICAgICAgICByZXN1bHRzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbGllbnQucmVwb3J0KGNvbnRleHQsIGRldGFpbHMsIGRlY2lzaW9uLCBydWxlcyk7XG4gICAgICAgICAgICByZXR1cm4gZGVjaXNpb247XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBsb2dSZW1vdGVQZXJmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhpcyBpcyBhIHNlcGFyYXRlIGZ1bmN0aW9uIHNvIGl0IGNhbiBiZSBjYWxsZWQgcmVjdXJzaXZlbHlcbiAgICBmdW5jdGlvbiB3aXRoUnVsZShiYXNlUnVsZXMsIHJ1bGUpIHtcbiAgICAgICAgY29uc3QgcnVsZXMgPSBbLi4uYmFzZVJ1bGVzLCAuLi5ydWxlXS5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgIHJldHVybiBPYmplY3QuZnJlZXplKHtcbiAgICAgICAgICAgIHdpdGhSdWxlKHJ1bGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gd2l0aFJ1bGUocnVsZXMsIHJ1bGUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFzeW5jIHByb3RlY3QoY3R4LCByZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RlY3QocnVsZXMsIGN0eCwgcmVxdWVzdCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUoe1xuICAgICAgICB3aXRoUnVsZShydWxlKSB7XG4gICAgICAgICAgICByZXR1cm4gd2l0aFJ1bGUocm9vdFJ1bGVzLCBydWxlKTtcbiAgICAgICAgfSxcbiAgICAgICAgYXN5bmMgcHJvdGVjdChjdHgsIHJlcXVlc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBwcm90ZWN0KHJvb3RSdWxlcywgY3R4LCByZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICB9KTtcbn1cblxuZXhwb3J0IHsgYXJjamV0IGFzIGRlZmF1bHQsIGRldGVjdEJvdCwgZml4ZWRXaW5kb3csIHByb3RlY3RTaWdudXAsIHNlbnNpdGl2ZUluZm8sIHNoaWVsZCwgc2xpZGluZ1dpbmRvdywgdG9rZW5CdWNrZXQsIHZhbGlkYXRlRW1haWwgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/arcjet/index.js\n");

/***/ })

};
;